## 알고리즘
1. 카운팅정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하는 정렬, 선형 시간에 정렬하는 효율적인 알고리즘
- 시간 복잡도-> O(n+k)n은 리스트 길이, k는 정수의 최댓값
- 주어진 숫자 중 각 개수를 구하는 문제와 비슷  
- 만약 [1, 4, 1, 3] 이렇게 주어지면 빈도수는 [0, 2, 0, 1, 1]각 인덱스에 값의 수를 넣음
- 누적 합 기록 ->[0, 2, 2, 3, 4], 각 인덱스 에 대해0부터 끝까지 모든 원소의 빈도 수를 합한 값 -> 누적합 배열의 값은 '해당 값 이하의 모든 원소가 입력 배열에서 몇개 있는지'를 파악.
- 누적합[3]은 입력배열 3이하의 원소가 총 3개 있다는 뜻.
- 방향은 계속 오른쪽에서 왼쪽으로 정렬됨. 그 이하에 몇개가 있다 를 확인할 수 있음
- 최종 위치 결정 -> 누적 함 배열의 각 값은 해당 원소가 최종 정렬된 배열에서 차지할 오른쪽 경계 위치를 알려줌.
- 값이 3인 원소의 누적 합이 3이라면, 최종 정렬된 배열의 인덱스 2에 위치하게 된다는 의미 -> [1, 1, 3, 4]여기서 3은 2번 인덱스 위치
- 따라서 실제 배치할 때는 해당 누적합 값을 1 감소시킨 위치에 원소를 배치 

2. 각 정렬 특징
- 버블 정렬-코딩이 가장 손쉽다
- 카운팅 정렬- n이 비교적 작을 때만 가능하다.

3. 완전검색
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열, 그리고 확인하는 기법
- Brute-force, generate-and-text기법이라고도 불린다.
- 모든 경우의 수를 테스트하기에 경우의 수가 작을수록 좋다.
- 수행속도는 느리지만 해답을 찾아낼 확률이 높다.
  
4. 탐욕 알고리즘
- 그리디 알고리즘이라고도 한다.
- 최적해를 구하는 근시안적 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간이 최적이라고 생각되는 것을 선택해 나가는 방식
- 그 선택의 시점에는 최적이지만 그 선택들을 계속 수집해서 최종적인 답을 만들었다고 해도 그것이 최적이라는 보장은 없음.
- 동작과정은 해 선택-> 실행 가능성 검사-> 해 검사 순서로 이루어진다. 해 검사에서 해가 완성 안되면 해 선택부터 다시 시작한다.
  
- > [!결론]  
> 알고리즘은 결국 얼마나 많이 반복하느야에 따라 달려있음.

## 검색
- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업.
- 목적하는 탐색 키를 가진 항목을 찾는 것.  
  - 탐색키: 자료를 구별하여 인식할 수 있는 키
  - 순차검색, 이진검색, 해쉬로 나눠짐.
### 순차검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 정렬되어 있는 경우와 정렬되어 있지 않은 경우 2가지로 나누어짐.
- 검색과정:  
  - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
  - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
  - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 실패.
-  ex) num = 4, 9, 11, 21, 2, 19 
-  이때 2를 찾으려면 맨 처음 인덱스부터 하나씩 비교해가며 2가 있는지를 확인.
-  찾으면 검색 성공.
-  아니면 검색 실패.
-  검색 과정  
   - 자료가 오름차순이라 가정하면 순차적으로 검색하고 키 값이 검색하는 값보다 크면 검색 종료  
   - def seq_search(a, n, key):  
        for i in range(n):   
          if a[i] == key:
            return 1  
        return -1  
        arr = [4, 9, 11, 23, 2, 19, 7]  
        print(seq_search(arr, len(arr), 8))
  - 이런 식으로 for문도 되지만 while도 된다.  
    -  while i < n and a[i] < key 이런식으로 조건을 써도 된다.

### 이진검색
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
- 이를 위해서는 자료가 정렬된 상태여야 한다.
- 검색과정  
  - 자료 중앙에 있는 원소를 고른다.
  - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
  - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색 수행
  - 크다면 오른쪽 반에 대해 새로 검색 수행
  - 이때도 각 반의 중앙에 있는 원소부터 비교하며 진행한다.
  - 찾고자 하는 값을 찾을 때까지 위의 과정을 반복한다.
  - 못찾으면 실패.
### 인덱스
- 인덱스 라는 용어는 데이터베이스에서 유래, 테이블에 대한 동작 속도를 높혀주는 자료 구조
- 데이터 베이스 분야가 아닌 곳에서는 look up table 등의 용어를 사용하기도 한다.
- 인덱스를 저장하는데 필요한 공간한 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 
- 이는 보통 인덱스틑 키-필드만 갖고 있고 테이블의 다른 세부 항목은 갖고 있지 않기 때문이다.
  
### 선택정렬
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식(오름차순의 경우)
- 정렬과정  
  - 주어진 리스트 중에서 최솟값을 찾는다.
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다. 
- 버블 정렬과 비슷하긴 하지만 버블 정렬은 앞에서 부터 각 인덱스를 비교하여 변경하는 것이다.
- 선택 정렬은 최솟값을 찾은 후 그 값을 앞에서 부터 인덱스를 변경한다.
- 즉, 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 선택 정렬이라고 한다.
- 선택 과정:  
  - 정렬 알고리즘을 이용하여 정렬 하기
  - 원하는 순서에 있는 원소 가져오기

### string
- 컴퓨터는 숫자만 저장할 수 있다.
- 글자 A를 메모리에서 저장하는 것은 2진수로 변환해서 저장하는 것이다.
- 영어의 경우 대소문자 합해서 52자이므로 6(64가지)비트면 모두 표현 할 수 있는데 이를 코드체계라고 한다.  

### ASCII
- 인터넷이 세계화 되면서 다양한 문자 표현에 문제가 생겼다. 그래서 ASCII라는 문자 인코딩 표준이 제정됨.
- 7-bit인코딩으로 128문자 표현 가능
- 33개의 출력불가능한 제어문자들과 공백을 포함한 95개의 출력 가능한 문자들로 이루어져 있다.
- 확장 아스키는 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.
- 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 아스키 형식을 사용한다.
- 그런데 인터넷이 전 세계로 발전하며 국가간에 정보를 주고 받을 때 문제 발생
- 그래서 다국어 처리를 위한 표준을 만들었고 이를 유니코드 라고 한다.
  
### 유니코드
- 다국어 처리를 위해 만든 표준
- 이도 다시 characer set으로 분류된다.  
  - UCS-2, UCS-4
- 하지만, 바이트 순서에 대해서 표준화 못함.
- 파일을 인식 시 이 파일이 usc-2, usc-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생함.
- 그래서 적당한 외부 인코딩이 필요하게 됨
- 유니코드 인코딩(UTF)  
  - UTF-8
  - UTF-16
  - UTF-32

- 파이썬 이코딩
- 2.x버전 - 아스키
- 3.x버전 - 유니코드 UTF-8-생략가능
  
### 문자열
- 파이썬이 아닌 다른 언어의 경우 문자열 데이터를 저장, 처리하는 클래스를 제공  
  - `String` 클래스를 사용
- C은 아스키 코드로 저장, JAVA는 Unicode UTF-8로 저장
- 파이썬에서 s1 = list(input()) 과 s2 = input() 저장 방법이 다르다. 
- s1은 []이 안에 값이 들어가 있고 s2는 그냥 출력이 된다. 만약 abc를 이 2개에 넣는다 가정하자.
- s1 = ['a', 'b', 'c'], s2 = abc 이렇게 출력 됨
- 그리고 문자열 일부만 변경은 안된다!
- 파이썬:  

- **char 타입이 없으며**, 텍스트 데이터의 취급 방법이 통일 되어 있음
- **문자열은 시퀀스 자료형**으로 분류  
= 시퀀스 자료형에서 사용가능한 인덱싱, 슬라이싱 등 사용가능
`replace()`, `split()`, `isalpha()`, `find()` ...
- 홑따옴표, 쌍따옴표, 쌍따옴표 3개
- `+` 를 이용해서 문자열 연결
- `*` 를 이용해서 수만큼 문자열 반복
- 문자열은 튜플과 같이 **요소값을 변경할 수 없음**
- UTF-8로 문자열 저장
- s = ['a', 'b', 'c'], print(''.join(s)) -> abc
- 문자열을 뒤집기 위해서는 문자열 길이를 2로 나눈 후 그에 나온 값의 횟수 만큼 서로 교환한다. 

### 연산
- 자바에서는 equls(메소드를 제공)
- 파이썬에서는 == 연산자와 is 연산자 제공
- 파이썬에서 정수 256까지는 하댕 값이 존재하면 기존의 객체를 바인딩 한다/
- 256까지는 변수에 같은 수를 넣으면 is를 하면 true 반환한다.