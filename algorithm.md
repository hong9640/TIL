## 알고리즘
1. 카운팅정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하는 정렬, 선형 시간에 정렬하는 효율적인 알고리즘
- 시간 복잡도-> O(n+k)n은 리스트 길이, k는 정수의 최댓값
- 주어진 숫자 중 각 개수를 구하는 문제와 비슷  
- 만약 [1, 4, 1, 3] 이렇게 주어지면 빈도수는 [0, 2, 0, 1, 1]각 인덱스에 값의 수를 넣음
- 누적 합 기록 ->[0, 2, 2, 3, 4], 각 인덱스 에 대해0부터 끝까지 모든 원소의 빈도 수를 합한 값 -> 누적합 배열의 값은 '해당 값 이하의 모든 원소가 입력 배열에서 몇개 있는지'를 파악.
- 누적합[3]은 입력배열 3이하의 원소가 총 3개 있다는 뜻.
- 방향은 계속 오른쪽에서 왼쪽으로 정렬됨. 그 이하에 몇개가 있다 를 확인할 수 있음
- 최종 위치 결정 -> 누적 함 배열의 각 값은 해당 원소가 최종 정렬된 배열에서 차지할 오른쪽 경계 위치를 알려줌.
- 값이 3인 원소의 누적 합이 3이라면, 최종 정렬된 배열의 인덱스 2에 위치하게 된다는 의미 -> [1, 1, 3, 4]여기서 3은 2번 인덱스 위치
- 따라서 실제 배치할 때는 해당 누적합 값을 1 감소시킨 위치에 원소를 배치 

2. 각 정렬 특징
- 버블 정렬-코딩이 가장 손쉽다
- 카운팅 정렬- n이 비교적 작을 때만 가능하다.

3. 완전검색
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열, 그리고 확인하는 기법
- Brute-force, generate-and-text기법이라고도 불린다.
- 모든 경우의 수를 테스트하기에 경우의 수가 작을수록 좋다.
- 수행속도는 느리지만 해답을 찾아낼 확률이 높다.
  
4. 탐욕 알고리즘
- 그리디 알고리즘이라고도 한다.
- 최적해를 구하는 근시안적 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간이 최적이라고 생각되는 것을 선택해 나가는 방식
- 그 선택의 시점에는 최적이지만 그 선택들을 계속 수집해서 최종적인 답을 만들었다고 해도 그것이 최적이라는 보장은 없음.
- 동작과정은 해 선택-> 실행 가능성 검사-> 해 검사 순서로 이루어진다. 해 검사에서 해가 완성 안되면 해 선택부터 다시 시작한다.
  
> [결론]  
> 알고리즘은 결국 얼마나 많이 반복하느야에 따라 달려있음.