## 알고리즘
1. 카운팅정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하는 정렬, 선형 시간에 정렬하는 효율적인 알고리즘
- 시간 복잡도-> O(n+k)n은 리스트 길이, k는 정수의 최댓값
- 주어진 숫자 중 각 개수를 구하는 문제와 비슷  
- 만약 [1, 4, 1, 3] 이렇게 주어지면 빈도수는 [0, 2, 0, 1, 1]각 인덱스에 값의 수를 넣음
- 누적 합 기록 ->[0, 2, 2, 3, 4], 각 인덱스 에 대해0부터 끝까지 모든 원소의 빈도 수를 합한 값 -> 누적합 배열의 값은 '해당 값 이하의 모든 원소가 입력 배열에서 몇개 있는지'를 파악.
- 누적합[3]은 입력배열 3이하의 원소가 총 3개 있다는 뜻.
- 방향은 계속 오른쪽에서 왼쪽으로 정렬됨. 그 이하에 몇개가 있다 를 확인할 수 있음
- 최종 위치 결정 -> 누적 함 배열의 각 값은 해당 원소가 최종 정렬된 배열에서 차지할 오른쪽 경계 위치를 알려줌.
- 값이 3인 원소의 누적 합이 3이라면, 최종 정렬된 배열의 인덱스 2에 위치하게 된다는 의미 -> [1, 1, 3, 4]여기서 3은 2번 인덱스 위치
- 따라서 실제 배치할 때는 해당 누적합 값을 1 감소시킨 위치에 원소를 배치 

2. 각 정렬 특징
- 버블 정렬-코딩이 가장 손쉽다
- 카운팅 정렬- n이 비교적 작을 때만 가능하다.

3. 완전검색
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열, 그리고 확인하는 기법
- Brute-force, generate-and-text기법이라고도 불린다.
- 모든 경우의 수를 테스트하기에 경우의 수가 작을수록 좋다.
- 수행속도는 느리지만 해답을 찾아낼 확률이 높다.
  
4. 탐욕 알고리즘
- 그리디 알고리즘이라고도 한다.
- 최적해를 구하는 근시안적 방법
- 여러 경우 중 하나를 결정해야 할 때마다 그 순간이 최적이라고 생각되는 것을 선택해 나가는 방식
- 그 선택의 시점에는 최적이지만 그 선택들을 계속 수집해서 최종적인 답을 만들었다고 해도 그것이 최적이라는 보장은 없음.
- 동작과정은 해 선택-> 실행 가능성 검사-> 해 검사 순서로 이루어진다. 해 검사에서 해가 완성 안되면 해 선택부터 다시 시작한다.
  
- > [!결론]  
> 알고리즘은 결국 얼마나 많이 반복하느야에 따라 달려있음.

## 검색
- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업.
- 목적하는 탐색 키를 가진 항목을 찾는 것.  
  - 탐색키: 자료를 구별하여 인식할 수 있는 키
  - 순차검색, 이진검색, 해쉬로 나눠짐.
### 순차검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 정렬되어 있는 경우와 정렬되어 있지 않은 경우 2가지로 나누어짐.
- 검색과정:  
  - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
  - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
  - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 실패.
-  ex) num = 4, 9, 11, 21, 2, 19 
-  이때 2를 찾으려면 맨 처음 인덱스부터 하나씩 비교해가며 2가 있는지를 확인.
-  찾으면 검색 성공.
-  아니면 검색 실패.
-  검색 과정  
   - 자료가 오름차순이라 가정하면 순차적으로 검색하고 키 값이 검색하는 값보다 크면 검색 종료  
   - def seq_search(a, n, key):  
        for i in range(n):   
          if a[i] == key:
            return 1  
        return -1  
        arr = [4, 9, 11, 23, 2, 19, 7]  
        print(seq_search(arr, len(arr), 8))
  - 이런 식으로 for문도 되지만 while도 된다.  
    -  while i < n and a[i] < key 이런식으로 조건을 써도 된다.

### 이진검색
- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
- 이를 위해서는 자료가 정렬된 상태여야 한다.
- 검색과정  
  - 자료 중앙에 있는 원소를 고른다.
  - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
  - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색 수행
  - 크다면 오른쪽 반에 대해 새로 검색 수행
  - 이때도 각 반의 중앙에 있는 원소부터 비교하며 진행한다.
  - 찾고자 하는 값을 찾을 때까지 위의 과정을 반복한다.
  - 못찾으면 실패.
### 인덱스
- 인덱스 라는 용어는 데이터베이스에서 유래, 테이블에 대한 동작 속도를 높혀주는 자료 구조
- 데이터 베이스 분야가 아닌 곳에서는 look up table 등의 용어를 사용하기도 한다.
- 인덱스를 저장하는데 필요한 공간한 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 
- 이는 보통 인덱스틑 키-필드만 갖고 있고 테이블의 다른 세부 항목은 갖고 있지 않기 때문이다.
  
### 선택정렬
- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식(오름차순의 경우)
- 정렬과정  
  - 주어진 리스트 중에서 최솟값을 찾는다.
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다. 
- 버블 정렬과 비슷하긴 하지만 버블 정렬은 앞에서 부터 각 인덱스를 비교하여 변경하는 것이다.
- 선택 정렬은 최솟값을 찾은 후 그 값을 앞에서 부터 인덱스를 변경한다.
- 즉, 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 선택 정렬이라고 한다.
- 선택 과정:  
  - 정렬 알고리즘을 이용하여 정렬 하기
  - 원하는 순서에 있는 원소 가져오기