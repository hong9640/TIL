## 알고리즘

1. 카운팅정렬
- 항목들의 순서를 결정하기 위해 집합에 각 항목이 몇 개씩 있는지 세는 작업을 하는 정렬, 선형 시간에 정렬하는 효율적인 알고리즘

- 시간 복잡도-> O(n+k)n은 리스트 길이, k는 정수의 최댓값

- 주어진 숫자 중 각 개수를 구하는 문제와 비슷  

- 만약 [1, 4, 1, 3] 이렇게 주어지면 빈도수는 [0, 2, 0, 1, 1]각 인덱스에 값의 수를 넣음

- 누적 합 기록 ->[0, 2, 2, 3, 4], 각 인덱스 에 대해0부터 끝까지 모든 원소의 빈도 수를 합한 값 -> 누적합 배열의 값은 '해당 값 이하의 모든 원소가 입력 배열에서 몇개 있는지'를 파악.

- 누적합[3]은 입력배열 3이하의 원소가 총 3개 있다는 뜻.

- 방향은 계속 오른쪽에서 왼쪽으로 정렬됨. 그 이하에 몇개가 있다 를 확인할 수 있음

- 최종 위치 결정 -> 누적 함 배열의 각 값은 해당 원소가 최종 정렬된 배열에서 차지할 오른쪽 경계 위치를 알려줌.

- 값이 3인 원소의 누적 합이 3이라면, 최종 정렬된 배열의 인덱스 2에 위치하게 된다는 의미 -> [1, 1, 3, 4]여기서 3은 2번 인덱스 위치

- 따라서 실제 배치할 때는 해당 누적합 값을 1 감소시킨 위치에 원소를 배치 

- 카운팅 정렬 예시:  
  
  - 카운팅 정렬은 누적합을 사용하여 푸는 방법입니다. 위의 설명과 같이 각 배열의 있는 숫자의 빈도수를 새로운 리스트에 넣고 이를 누적합으로 나타낸 뒤 기존 데이터의 인덱스의 값을 빈도수의 값의 인덱스에서 뺀 뒤 이를 결과 값에 새로 배치하는 방법입니다.
  
  - 아래는 예시 코드 입니다. 
  
  - def counting_sort(input_arr, k):  
    '''
    카운팅 정렬 함수  
    input_arr : 정렬할 입력 배열 (각 원소는 0 이상 k 이하의 정수)
    k : 입력 배열 내 원소의 최대값 (데이터 범위를 의미)
    '''
    
    - 1. k+1 크기의 카운팅 배열을 0으로 초기화 (인덱스 0부터 k까지 사용)  
         counting_arr = [0] * (k + 1)
    
    - 2. 입력 배열 내 각 원소의 빈도수를 counting_arr에 기록
    
    - (각 요소가 몇 번 나왔는지 확인해야 한다.)  
      for num in input_arr:  
        counting_arr[num] += 1
    
    - 3. 누적 합을 계산하여 각 원소가 정렬된 배열 내에서 차지할 위치를 결정
    
    - (누적 합 배열을 만들어야 한다.)  
      for i in range(1, k + 1):  
         이전까지 나온 수들의 합을 누적하는 코드  
        counting_arr[i] += counting_arr[i - 1]  
    
    - 4. 결과 배열 초기화: 입력 배열과 같은 크기로 생성  
         result_arr = [0] * len(input_arr)  
    
    - 5. 입력 배열을 역순으로 순회하며, 각 원소를 결과 배열의 올바른 위치에 배치
    
    - (역순 순회는 정렬의 안정성을 보장하기 위한 기법)  
    
    - for i in range(len(input_arr) - 1, -1, -1):  
      for num in reversed(input_arr):  
        counting_arr[num] -= 1  # 누적 합에서 해당 원소의 위치 인덱스를 하나 감소시킴  
        result_arr[counting_arr[num]] = num  
    
    return result_arr

# 테스트 예시

a = [0, 4, 1, 3, 1, 2, 4, 1]
print('정렬 결과:', counting_sort(a, 5))  # 출력 예시: [0, 1, 1, 1, 2, 3, 4, 4]

1. 각 정렬 특징
- 버블 정렬-코딩이 가장 손쉽다

- 카운팅 정렬- n이 비교적 작을 때만 가능하다.
1. 완전검색
- 문제의 해법으로 생각할 수 있는 모든 경우의 수를 나열, 그리고 확인하는 기법

- Brute-force, generate-and-text기법이라고도 불린다.

- 모든 경우의 수를 테스트하기에 경우의 수가 작을수록 좋다.

- 수행속도는 느리지만 해답을 찾아낼 확률이 높다.
1. 탐욕 알고리즘
- 그리디 알고리즘이라고도 한다.

- 최적해를 구하는 근시안적 방법

- 여러 경우 중 하나를 결정해야 할 때마다 그 순간이 최적이라고 생각되는 것을 선택해 나가는 방식

- 그 선택의 시점에는 최적이지만 그 선택들을 계속 수집해서 최종적인 답을 만들었다고 해도 그것이 최적이라는 보장은 없음.

- 동작과정은 해 선택-> 실행 가능성 검사-> 해 검사 순서로 이루어진다. 해 검사에서 해가 완성 안되면 해 선택부터 다시 시작한다.

- > [!결론]  
  > 알고리즘은 결국 얼마나 많이 반복하느야에 따라 달려있음.

## 이차원 배열

- 흔히 보이는 바둑판 모양, N*N 형식의 사각형 배열을 이차 배열이라 한다.
- 이차배열 코드 예시:  
  - b = [[0] * 5 for _ in range(5)]  
    arr = [[0] * M for _ in range(N)]  
    arr = [list(map(int, input().  
    N = int(input())  
    split())) for _ in range(N)]
    이차 배열 만드는 방법. 이 형식을 써야 한다.
- 기본적으로는 행을 우선한다.
- 지그재그 순회 등 방법은 여러가지이다.  
  - 기본형식

import sys

sys.stdin = open('input.txt')

N, M = map(int, input().split())  
arr = [list(map(int, input().split())) for _ in range(N)]

 i 행의 좌표  
 j 열의 좌표

for i in range(N):  
    for j in range(M):  
        print(arr[i][j], end=' ')  
"""
0 1 2 3 4 5 6 7 8 9 10 11
"""

- 이것은 행 우선 이고 열 우선은 for문에서 j열과 i열을 서로 뒤바꾸면 된다.

- 지그재그는 행 우선순회에 출력 코드만 다르다.

- print(arr[i][j + (M - 1 - 2 * j) * (i % 2)], end=' ')

- 행의 길이   
  N = len(arr)

- 열의 길이 -> 인덱스를 주의  
  M = len(arr[0])

## 검색

- 저장되어 있는 자료 중에서 원하는 항목을 찾는 작업.
- 목적하는 탐색 키를 가진 항목을 찾는 것.  
  - 탐색키: 자료를 구별하여 인식할 수 있는 키
  - 순차검색, 이진검색, 해쉬로 나눠짐.
    
    ### 순차검색
- 일렬로 되어 있는 자료를 순서대로 검색하는 방법
- 정렬되어 있는 경우와 정렬되어 있지 않은 경우 2가지로 나누어짐.
- 검색과정:  
  - 첫 번째 원소부터 순서대로 검색 대상과 키 값이 같은 원소가 있는지 비교하며 찾는다.
  - 키 값이 동일한 원소를 찾으면 그 원소의 인덱스를 반환한다.
  - 자료구조의 마지막에 이를 때까지 검색 대상을 찾지 못하면 실패.
- ex) num = 4, 9, 11, 21, 2, 19 
- 이때 2를 찾으려면 맨 처음 인덱스부터 하나씩 비교해가며 2가 있는지를 확인.
- 찾으면 검색 성공.
- 아니면 검색 실패.
- 검색 과정  
  - 자료가 오름차순이라 가정하면 순차적으로 검색하고 키 값이 검색하는 값보다 크면 검색 종료  
  - def seq_search(a, n, key):  
       for i in range(n):   
    
         if a[i] == key:
           return 1  
    
       return -1  
       arr = [4, 9, 11, 23, 2, 19, 7]  
       print(seq_search(arr, len(arr), 8))
  - 이런 식으로 for문도 되지만 while도 된다.  
    - while i < n and a[i] < key 이런식으로 조건을 써도 된다.

### 이진검색

- 자료의 가운데에 있는 항목의 키 값과 비교하여 다음 검색의 위치를 결정하고 검색을 계속 진행하는 방법
- 이를 위해서는 자료가 정렬된 상태여야 한다.
- 검색과정  
  - 자료 중앙에 있는 원소를 고른다.
  - 중앙 원소의 값과 찾고자 하는 목표 값을 비교한다.
  - 목표 값이 중앙 원소의 값보다 작으면 자료의 왼쪽 반에 대해서 새로 검색 수행
  - 크다면 오른쪽 반에 대해 새로 검색 수행
  - 이때도 각 반의 중앙에 있는 원소부터 비교하며 진행한다.
  - 찾고자 하는 값을 찾을 때까지 위의 과정을 반복한다.
  - 못찾으면 실패.  
  - def binary_search(arr, target):  
    left = 0  
    right = len(arr) - 1  
    
    while left <= right:  
        mid = (left + right) // 2  

        if arr[mid] == target:  
            return mid  # 검색 성공 시 인덱스 반환  
        elif arr[mid] > target:  
            right = mid - 1  
        else:  
            left = mid + 1  

    return -1  # 검색 실패 시 -1 반환

# 예시
numbers = [2, 4, 7, 9, 11, 19, 23]
print(binary_search(numbers, 11))  # 4 (인덱스 4)
print(binary_search(numbers, 10))  # -1 (없음)
    
  ### 인덱스
- 인덱스 라는 용어는 데이터베이스에서 유래, 테이블에 대한 동작 속도를 높혀주는 자료 구조
- 데이터 베이스 분야가 아닌 곳에서는 look up table 등의 용어를 사용하기도 한다.
- 인덱스를 저장하는데 필요한 공간한 보통 테이블을 저장하는데 필요한 디스크 공간보다 작다. 
- 이는 보통 인덱스틑 키-필드만 갖고 있고 테이블의 다른 세부 항목은 갖고 있지 않기 때문이다.

### 선택정렬

- 주어진 자료들 중 가장 작은 값의 원소부터 차례대로 선택하여 위치를 교환하는 방식(오름차순의 경우)
- 정렬과정  
  - 주어진 리스트 중에서 최솟값을 찾는다.
  - 그 값을 리스트의 맨 앞에 위치한 값과 교환한다.
  - 맨 처음 위치를 제외한 나머지 리스트를 대상으로 위의 과정을 반복한다. 
- 버블 정렬과 비슷하긴 하지만 버블 정렬은 앞에서 부터 각 인덱스를 비교하여 변경하는 것이다.
- 선택 정렬은 최솟값을 찾은 후 그 값을 앞에서 부터 인덱스를 변경한다.
- 즉, 저장되어 있는 자료로부터 k번째로 큰 혹은 작은 원소를 찾는 방법을 선택 정렬이라고 한다.
- 선택 과정:  
  - 정렬 알고리즘을 이용하여 정렬 하기
  - 원하는 순서에 있는 원소 가져오기

### string

- 컴퓨터는 숫자만 저장할 수 있다.
- 글자 A를 메모리에서 저장하는 것은 2진수로 변환해서 저장하는 것이다.
- 영어의 경우 대소문자 합해서 52자이므로 6(64가지)비트면 모두 표현 할 수 있는데 이를 코드체계라고 한다.  

### ASCII

- 인터넷이 세계화 되면서 다양한 문자 표현에 문제가 생겼다. 그래서 ASCII라는 문자 인코딩 표준이 제정됨.
- 7-bit인코딩으로 128문자 표현 가능
- 33개의 출력불가능한 제어문자들과 공백을 포함한 95개의 출력 가능한 문자들로 이루어져 있다.
- 확장 아스키는 부가적인 문자를 128개 추가할 수 있게 하는 부호이다.
- 오늘날 대부분의 컴퓨터는 문자를 읽고 쓰는데 아스키 형식을 사용한다.
- 그런데 인터넷이 전 세계로 발전하며 국가간에 정보를 주고 받을 때 문제 발생
- 그래서 다국어 처리를 위한 표준을 만들었고 이를 유니코드 라고 한다.

### 유니코드

- 다국어 처리를 위해 만든 표준

- 이도 다시 characer set으로 분류된다.  
  
  - UCS-2, UCS-4

- 하지만, 바이트 순서에 대해서 표준화 못함.

- 파일을 인식 시 이 파일이 usc-2, usc-4인지 인식하고 각 경우를 구분해서 모두 다르게 구현해야 하는 문제가 발생함.

- 그래서 적당한 외부 인코딩이 필요하게 됨

- 유니코드 인코딩(UTF)  
  
  - UTF-8
  - UTF-16
  - UTF-32

- 파이썬 이코딩

- 2.x버전 - 아스키

- 3.x버전 - 유니코드 UTF-8-생략가능

### 문자열

- 파이썬이 아닌 다른 언어의 경우 문자열 데이터를 저장, 처리하는 클래스를 제공  
  
  - `String` 클래스를 사용

- C은 아스키 코드로 저장, JAVA는 Unicode UTF-8로 저장

- 파이썬에서 s1 = list(input()) 과 s2 = input() 저장 방법이 다르다. 

- s1은 []이 안에 값이 들어가 있고 s2는 그냥 출력이 된다. 만약 abc를 이 2개에 넣는다 가정하자.

- s1 = ['a', 'b', 'c'], s2 = abc 이렇게 출력 됨

- 그리고 문자열 일부만 변경은 안된다!

- 파이썬:  

- **char 타입이 없으며**, 텍스트 데이터의 취급 방법이 통일 되어 있음

- **문자열은 시퀀스 자료형**으로 분류  
  = 시퀀스 자료형에서 사용가능한 인덱싱, 슬라이싱 등 사용가능
  `replace()`, `split()`, `isalpha()`, `find()` ...

- 홑따옴표, 쌍따옴표, 쌍따옴표 3개

- `+` 를 이용해서 문자열 연결

- `*` 를 이용해서 수만큼 문자열 반복

- 문자열은 튜플과 같이 **요소값을 변경할 수 없음**

- UTF-8로 문자열 저장

- s = ['a', 'b', 'c'], print(''.join(s)) -> abc

- 문자열을 뒤집기 위해서는 문자열 길이를 2로 나눈 후 그에 나온 값의 횟수 만큼 서로 교환한다. 
### 회문
- def is_palindrome(text):  
    length = len(text)  
    for l in range(length // 2):  
        if text[l] != text[length - 1 - l]:  
            return False  
    return True  
- 이런 형식으로 풀면 된다.
sentence = "abcde"
print(is_palindrome(sentence))


### 연산

- 자바에서는 equls(메소드를 제공)
- 파이썬에서는 == 연산자와 is 연산자 제공
- 파이썬에서 정수 256까지는 하댕 값이 존재하면 기존의 객체를 바인딩 한다/
- 256까지는 변수에 같은 수를 넣으면 is를 하면 true 반환한다.

### string2

#### 패턴매칭

- 고지식한 패턴 검색 알고리즘  
  - 본문 문자열을 처음부터 끝까지 차례대로 순회하면서 패턴 내 문자들을 일일이 비교하는 방식
  - 예시:  
  - t = 'A pattern matching algorithm'
    p = 'rithm'

M = len(p) # 찾을 패턴의 길이
N = len(t) # 전체 텍스트의 길이

def brute_force_while(p, t):  
    i = 0 # t의 인덱스
    j = 0 # p의 인덱스
    # i와 j는 전부 범위 내의 인덱스   
    while j < M and i < N:  
        # 두개가 서로 다르면  
        # 아래의 조건문이 true일 때 그 아래 코드가 실행됨. j = -1까지. j = -1인 이유는 인덱스 이기 때문이다.  
        if t[i] != p[j]:  
            # t열의 시작인덱스에서 바로 다음 인덱스로 변경
            i = i - j
            # j는 원점으로  
            # j = -1 이유는 다음 비교가 0부터 시작되도록 하기 위해서 이다.  
            j = -1  
        #  if문이 flase 일 때. 즉 if t[i] == p[j] 일 때  
        i += 1  
        j += 1

    if j == M:
        return i - j # 검색 성공, 패턴의 시작 인덱스
    else:
        return -1 # 검색 실패

print(brute_force_while(p, t))

### KMP 알고리즘

- 불일치가 발생한 텍스트 스트링의 앞 부분에 어떤 문자가 있는지를 알고 있으므로, 불일치가 발생한 앞 부분에 대하여 다시 비교하지 않고 매칭을 수행
- 거의 안 쓸것이다. 그래서 참고만 하면 된다.

### 보이어 무어 알고리즘

- 오른쪽에서 왼쪽으로 비교
- 대부분 상용 소프트웨어에서 채택하고 있는 알고리즘
- 패턴의 오른쪽 끝에 있는 문자가 불일치하고 이 문자가 패턴 내에 존재하지 않는 경우, 이동거리는 무려 패턴의 길이 만큼 된다.
- 앞의 kmp와 고지식한 알고리즘과 고통점은 문자열의 문자를 적어도 한번 씩 훑는 다는 것이다.
- 보이어-무어 알고리즘은 패턴의 오른쪽 부터 비교하고 텍스트 문자를 다 보지 않아도 된다.

### 스택
- 말 그대로 물건을 쌓아 올리듯 자료를 쌓아 올린 형태의 자료 구조.
- 스택에 저장된 자료는 선형 구조를 갖는다.
- 선형구조- 자료 간의 관계가 1대1의 관계
- 일렬로 자료가 배치되어 있는 것을 뜻한다.
- 비선형구조- 자료 간의 관계가 1대 N의 관계
- 특성:  
  - 마지막에 삽입한 자료를 가장 먼저 꺼낸다.
  - 후입선출.
  - 물건 쌓는 것을 생각하면 편하다. 1, 2, 3을 넣었으면 3이 맨 마지막에 있으니 3, 2,1, 순서대로 꺼낼 수 있게 된다. 
- 주요 연산자:  
  - push: 데이터를 스택에 삽입
  - pop: 가장 최근에 삽입된 데이터를 스택에서 제거 및 반환
  - is_empty: 스택이 비어 있는지 확인
  - peek: 스택의 맨 위(마지막) 원소를 확인함 (삭제하지 않음)
- 스택은 선형 자료 구조로 쉽게 구현이 가능하다.  

### 괄호 검사
- 마지막에 삽입된 원소를 top이라 하며 [-1]인덱스로 접근 가능
- 괄호 종류: 소괄호 `()`, 중괄호 `{}`, 대괄호 `[]` 등
- **검사 조건**
    1. 왼쪽 괄호와 오른쪽 괄호 개수가 같아야 함
    2. 같은 종류의 괄호에서 왼쪽이 오른쪽보다 먼저 나와야 함
    3. 괄호는 서로 ‘포함 관계’를 이룸 (올바른 중첩)

**알고리즘 개요**

1. 문자열을 왼쪽부터 오른쪽까지 순회
2. 왼쪽 괄호를 만나면 **push**
3. 오른쪽 괄호를 만나면 **pop** 후, 짝이 맞는지 확인  
    1. 도중에 스택이 비어 있는데 오른쪽 괄호가 나오거나, 
    짝이 맞지 않는 경우 → 실패
4. 모든 문자를 처리한 후에도 스택이 비어 있지 않다면 → 실패
5. 그 외 경우에는 성공
- 1차원 배열을 사용하여 구현할 경우 구현이 용이하지만 스택의 크기 변경이 어렵다는 단점이 있다.
- 현재 배우지는 않지만 동적 연결리스트를 이용하여 이를 해결하는 방법이 있다.
- 이러면 구현이 복잡해지지만 메모리를 효율적으로 사용한다는 장점이 있다.
  
**함수 호출**
- 프로그램에서 함수를 호출하면 해당 함수의 실행이 끝나기 전까지는 이전 함수가 대기
- 가장 마지막에 실행한 함수가 가장 먼저 처리 완료
- 스택응용인 만큼 일반 스택 알고리즘과 같이 가장 나중에 쌓인 함수가 가장 먼저 처리된다.  

**재귀호출**
- 대표적으로 팩토리얼이 있다.
- 4, 3, 2, 1 이렇게 4!이 있다고 해보자.
- 4를 먼저 호출하고 3, 2, 1 이 순서대로 호출하고 1을 반환, 2, 3, 4 순서로 반환된다.
- 피보나치 수열도 재귀 호출이라고 할 수 있다. 
- 정확히는 피보나치 수열을 구하고 이의 i번째 항을 반환하는 함수를 재귀함수로 구현이 가능하다.
### DES, BFS 
- 중요한 것. 모든 코딩테스트에 다 나온다.
### 자료구조와 알고리즘
- 자료구조는 데이터를 저장, 조직, 관리하는 방식
- 알고리즘은 특정 문제를 해결하기 위한 명확한 절차나 방법론이다.
- 자료구조와 알고리즘은 서로 상호 보완적이고 문제 해결 역할을 한다.