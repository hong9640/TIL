# 장고
- 어떻게 풀기 보다는 어떻게 조합할지에 집중해야 한다.
- 프레임워크를 통해 최종적으로 웹 어플리케이션을 개발한다.
- 프레임워크는 이미 만들어진 도구로 문서와 예제 코드를 보며 활용법을 빠르게 습득하는 것이다.
- 그래서 프레임워크는 조립과 활용에 초점을 맞춘다.
## 웹 어플리케이션 개발
- 인터넷을 통해 사용자에게 제공되는 소프트웨어 프로그램을 구축화는 과정
- 웹의 동장 방식은 클라이언트-서버 구조로 clinet 즉, 우리가 서버에 요청하면 서버가 응답을 하는 구조이다. 이 틀에서 벗어나지 않는다.
- 클라이언트는 사용자의 웹 브라우저, 모바일 앱을 말한다. 그리고 서버는 웹 서버, 데이터베이스 서버를 말한다.
- 조금 자세히 하면 먼저 클라이언트에서 요청을 하면 전 세계 어디에 있는 서버에 파일을 달라고 요청한 것이다. 그리고 해당 서버는 데이터베이스에서 파일을 찾아 응답하고 클라이언트는 전달받은 파일을 사람이 볼 수 있도록 해석해주고 사용자는 구글의 메인페이지를 보게 됨.
- 다시 말하지만 요청-응답은 절대로 변하지 않는 구조이다.
## 프론트엔드, 백엔드
- 프론트엔드는 UI를 구성, 사용자가 어플리케이션과 상호작용 할 수 있도록 한다. 백엔드는 서버측과 동작하며, 클라이언트의 요청에 대한 데이터베이스와의 상호 작용 등을 담당한다.
- 그리고 디장고는 백엔드 즉, 서버 쪽이다.
## 프레임워크
- 웹 프레임워크는 웹 어플리케이션을 빠르게 개발할 수 있도록 도와주는 도구이다. 보통 규칙, 라이브러리 등을 제공한다.
## django framework
- 일단 장고다. 'd' 는 묵음임.
- 이것은 파이썬 기발의 대표적인 웹 프레임워크이다.
- 장고를 사용하는 이유는 다양성, 확장성, 보안, 커뮤니티 지원 기능을 가지고 있기 때문이다.
- 장고는 대규모 프레임워크에서 사용되는데 대표적으로 인스타그램, 드롭박스 같은 것이 있다.
- 그리고 작년 기준으로 장고는 2번째로 인기있는 백엔드 프레임워크이다.
- 그리고 우리는 장고를 사용해 서버를 구현할 것이다.
## 가상환경
- 하나의 컴퓨터 안에서 또 다른 독립된 파이썬 환경
- 예를 들어 한 개발자가 2개의 프로젝트를 진행해야 할 때 2개의 프로젝트를 다른 패키지 버전 사용을 위한 독립적인 개발 환경이 필요할 때 쓰인다. 서로 다른 패키지를 사용하면 충돌이 발생하기에 이를 피하기 위해 독립적인 개발 환경이 필요하며 이 상황에 시나리오가 필요하다.
- 조금 더 비유하면 같은 집(컴퓨터) 안에, 방(가상환경)을 따로 만들어 두고 필요한 물건(라이브러리, 패키지 등)을 그 방에만 들여놓는 것과 비슷.
## 가상 환경 생성 및 활성화
- 1. python - m venv venv: 현 디렉토리에 venv라는 폴더가 생성되고 venv 폴더안에는 파이썬 실행파일, 라이브러리 등을 담을 공간이 마련된다. 
- 또한 이 경우에 venv라는 이름의 가상환경을 생성한 것이며 임의의 이름으로 생성이 가능하나 관례적인 venv 이름을 사용
- 2. 가상환경 활성화
- source venv/Scripts/activate
- 3. 가상환경 종료
- 터미널을 강제 종료 해도 되긴 하는데 비추천
- deactivate 쓰기
- 그러면 원상태로 돌아온다.
## 의존성 패키지
- 프로젝트가 의존하는 개별 라이브러리들을 카리키는 말이다.
- 1. 패키지 목록 확인
- pip list
- 현재 가상환경에 설치된 라이브러리 목록을 확인
- 2. pip freeze > requirements.txt
- 의존성 기록
- 이 파일을 만드면 나중에 동일한 환경을 재현할 때 유용하다.
- 그리고 pip freeze 명령어는 가상환경에 설치된 모든 패키지를 버전과 함께 출력한다.
- 협업 시에도 팀원들이 똑같은 버전의 라이브러리를 설치하도록 공유 가능
- 일단 freeze 먼저 하고 pip freeze > requirements.txt 하기
- 패키지마다 버전이 다르고 프로젝트가 커질수록 사용하는 패키지 개수도 늘어나기 때문에 의존성 리스트를 만들어 어떤 버전을 쓰고 있는지 기록 및 공유가 필수적이다.
- 그리고 무조건 requirements.txt 이 파일명으로 만들어야 한다.
- 3. 의존성 패키지 기반 설치
- pip install -r requirements.txt
- 이 명령어를 쓰면 해당 텍스트에 기록된 패키지와 버전을 읽어와 같은 환경으로 설치한다.
- 라이브러리 설치 순서는 없긴 한데 간혹 가이드문서에 이 순서대로 설치하라고 뜨면 그대로 설치하면 된다.
- 4. 가상환경 주의사항
- 가상환경에 "들어오고 나오는" 것이 아니라 사용할 파이썬 환경을 "on/off"로 전환하는 개념
- venv의 환경에서 상위로 가도  venv는 꺼지지 않는다.
- 그런데 새 터미널 창을 열면 다시 활성화 해야 한다.
- 프로젝트마다 별도의 가상환경을 사용
- 일반적으로 가상환경 폴더 venv는 관련된 프로젝트와 동일한 경로에 위치시킴.
- 폴더venv는 .gitignore파일에 작성되어 원격저장소에 공유되지 않도록 해야 한다.
- 5. 가상환경이 필요한 이유
- 프로젝트마다 다른 버전의 라이브러리를 사용하고 의존성 충돌을 방지하며 팀원 간 협업을 위해 필요하다.
- 필수과정 요약:  
  - 1. 가상환경을 만든다
  - 2. 가상환경을 활성화한다.
  - 3. 필요한 의존성 패키지를 설치
  - 4. 현재 환경의 모든 패키지목록을 저장하여 의존성 관리
  - 5. 다른 컴퓨터나 팀원도 필요하다면 동일한 버전의 라이브러리를 설치
  - 6. 작업이 끝나면 deactive로 가상환경을 비활성화
## 프로젝트 생성
- django-admin startproject firstpjt . 이때 startproject까지는 무조건 외우기. 다음은 파일 이름
- python manage.py runserver: manage.py와 동일한 위치에서 명령어 진행
- 서버 확인
## 디자인 패턴
- 소프트웨어 설계에서 발생하는 문제를 해결하기 위한 일반적인 해결책
- 어플리케이션 구조는 이렇게 구성하자 라는 관행
- MVC 디자인 패턴:  
  - 데이터, 사용자 인터페이스, 비즈니스 로직을 분리한다.
  - (model, view, controller)
- 그런데 장고에서는 구조는는 같지만 이름을 바꿔서 부름
- MTV 디자인 패턴:  
  - (model, template, view)
  - 기존 mvs패턴과 동일하나 단순히 명칭을 다르게 정의한 것
  - 단순히 명칭만 변경
## 프로젝트와 앱
- 프로젝트 안에 앱이 여러개 있고 이것이 프로젝트를 구성한다.
- 만약 온라인 커뮤니티 카페를 만든다면 카페가 프로젝트이며 앱은 게시글, 댓글, 회원 관리라고 할 수 있다.
- 앱을 사용하기 위해서는 앱을 생성하고 앱을 등록해야 한다.
- 앱 생성:  
  - python manae.py startapp articles
  - 앱의 이름은 복수형으로 지정하는 것을 권장
- 앱 등록:  
  - 반드시 앱을 생성한 후에 등록해야 한다.
  - installed_apps에 'articles', 를 등록해야 한다.
## 프로젝트 및 앱 구조
- settings.py, urls.py, __init__.py, asgi.py, wsgi.py, manage.py
- 그런데 수정하는 것은 settings.py, urls.py 이렇게 2개 뿐이다. 나머지는 수정 안한다.
- 앱에서는 3개만 보면 된다. admin.py, models.py, views.py 
- 나머지는 수정 안한다.
## 요청과 응답
- 순서:  
  - 요청 -> urls.py -> views.py <-> (models.py, temlplates) -> 응답
- url경로는 반드시 '/'(slash로 끝나야 한다.)
## django temlate system
- 데이터 표현을 제어하면서 표현과 관련된 부분을 담당
- DTL: template에서 조건, 반복, 변수 등의 프로그래밍적 기능을 제공  
  - 1. variable: render함수의 세번째 인자로 딕셔너리 데이터 사용  
    - 딕셔너리 키에 해당하는 문자열이 template에서 사용 가능한 변수명이 된다.
    - {{variable}}
  - 2. filters: 표시할 변수를 수정할 때 사용(변수 | 필터)  
    - 연결이 가능하며 일부 필터는 인자를 받기도 한다.
    - 60개의 빌트인 필터 제공
    - {{variable|filter}}
  - 3. tags: 반복, 또는 논리를 수행하여 제어 흐름을 만든다.   
    - 일부 태그는 시작과 종료 태그가 필요
    - 24개의 빌트인 템플레이트 태그 제공
    - {% tag %}
  - 4. comments(주석)   
    - {%comment%}   
    - ...   
    - {%endcomment}   
    - 이런식으로 주석을 처리한다.
    - {#name#} 이런 식으로 단일 주석도 있다.
- 공식문서에서 사용법 등을 찾아야 하는데 사이트에서 찍는 것은 비추천
- django document 하고 다음에 필요한 것 예를 들면 list 이런 식으로 나열하고 검색
- 나오는 결과 중 알맞는 것 찾아서 보기
## 템플릿 상속:  
- 페이지의 공통 요소를 포함하고 기본 스켈레톤 템플릿을 작성하여 상속 구조를 구축
- block으로 범위를 지정한다.
- extends tag: {5 extends 'path' %}
- 자식 템플릿이 부모 템플릿을 확장한다는 것을 알림
- 반드시 자식 템플릿 최상단에 작성되어야 하고 2개 이상 사용 불가
- block tag: {%block name%} {%endblock name%}
- 하위 템플릿에서 재정의 할 수 있는 블록을 정의
- 상위 템플릿에 작성하며 하위 템플릿이 작성할 수 있는 공간을 지정하는 것
## 요청과 응답
- form tag: http 요청을 서버에 보내는 가장 편리한 방법
- form, input이 제일 중요. form은 외각, input은 받는 것
- 사용자로부터 할당된 데이터를 서버로 전송
- 우리가 검색하면 키로 받는다.
- 핵심은 query, 그리고 input에 name 이 없으면 검색 안됨
- action & method: 데이터를 어디(action)로 어떤 방식(method)으로 요청할지
- method에서 데이터를 어떤 방식으로 보낸 것인지 정의하는데 get, post가 있는데 get이 기본
- get: 검색, 조회
- post: 삭제, 수정, 생산 ...
- input: 사용자의 데이터를 입력 받는 요소로 핵심 속성은 name이다.
- name은 사용자가 입력한 데이터에 붙이는 이름(key)이다.
- 문자열은 &로 연결된 key-value로 연결, 기본 url과는 물음표(?)로 구분된다.
- 그리고 submit이 없으면 전송 안됨
- request.GET.get('message') 이게 request 객체에서 form 데이터 추출
## 장고 urls
- url dispatcher
- url 패텬을 정의하고 해당 패턴이 일치하는 요청을 처리할 view 함수를 연결
- 템플릿이 많은 부분이 중복되게 된다. 이를 해결하기 위한 방법이 variable routing 이다.
- url 일부에 변수를 포함시키는 것이다.
- 작성법: <path_converter:variable_name> 타입: 변수명
- path('articles/<int:num>/', views.detail)
- inclue(): 프로젝트 내부 앱들의 url을 참조할 수 있도록 매핑하는 함수
- from django.urls import path, include
- path('articles/', include('articles.urls'))
## url 이름 지정
- 기존 articles/ 주소가 articles/index/로 변경되면 해당 urlㅇㄹ 사용하는 모든 위치를 찾아가 변경해야 한다. 그래서 name을 사용해 url에 이름을 지정해준다
- naming url patterns: url에 이름을 지정
- path('articles/', views.detail, name='index 이렇게')
- 그러면 url을 작성하는 모든 곳에서 변경되는데 a와 form의 주소 쓰는데서 전부 바뀐다.
- {%url 'dinner'%} 이렇게
## url 이름 공간
- 만약 두 앱의 url 이름이 같으면 url 맨 위에 app_name = "name" 이렇게 app_name을 맨 위에 써야 한다.
## Model
- db의 테이블을 정의하고 데이터를 조작할 수 있는 기능들을 제공
- 테이블 구조를 설계하는 청사진
- 우리가 파이썬으로 보내면 장고가 sql로 바꿔줌
- 보통 프로젝트나 어플을 만들었을 때 기본적으로 import되어 있는 것은 무조건 쓰게 될 것 이라는 뜻.
- class Article(models.Model): 여기서 Model에 대한 모든 정보를 가지고 온다.
- django.db.models모듈의 Model이라는 부모 클래스를 상속받는다.
- Model은 model에 관련된 모든 코드가 이미 작성되어 있는 클래스
- 개발자는 가장 중요한 테이블 구조를 어떻게 설계할지에 대한 코드만 작성하기 위한 것이다.
- 상속을 활용한 프레임워크의 기능 제공
- 다음 줄의 title, content 같이 클래스의 변수명은 '필드'라고 부른다.
- 그리고 charfield, textfield는 model field로 데이터베이스 테이블의 열을 나타내는 중요한 구성요소이며 데이터의 유형과 제역 조건을 정의한다.
- title = models.CharField(max_length=10) 여기서 field는 데이터 타입을 결정한다. 그리고 클래스 상속, max_length=10 -> 10글자가 최대다. 그리고 이 옵션이 필수다.
- 헷갈리면 클래스 다시 복습하기!
- content = models.TextField() 이 코드의 TextField와 CharField의 기능은 다르다.
## Model Field
- db 테이블의 필드(열)을 정의하며, 해당 필드에 저장되는 데이터 타입과 제약 조건을 정의
- Field types(필드 유형):  
  - 데이터베이스에 저장될 데이터의 종류를 정의
  - charfield(): 제한된 길이의 문자열을 저장. 그래서 필드의 최대 길이를 결정하는 max_length는 필수 옵션이다.
  - textfield(): 길이 제한이 없는 대용량 텍스트를 저장하는데 무한대는 아니고 사용하는 시스템에 따라 달라진다.
  - 주요 필드 유형:  
    - 문자열 필드: charfield, textfield
    - 숫자 필드: integerfield, floatfield
    - 날짜/시간 필드: datefield, timefield, datetimefield
    - 파일 관련 필드: filefield, imagefield
    - 위의 필드들은 자주 쓰이는 필드 이다.
- Field Options(필드 옵션):  
  - 필드의 동작과 제약 조건을 정의
  - 위의 charfield에서 max_length가 필드 옵션
  - 제약조건: 특정 규칙을 강제하기 위해 테이블의 열이나 행에 적용되는 규칙이나 제한사항
  - 주요 필드 옵션:  
    - null: 데이터베이스에서 null값을 허용할지 여부를 결정
    - blank: form에서 빈 값을 허용할지 여부를 결정
    - default: 필드의 기본값을 설정
## Migrations
- 모델 클래스의 변경사항을 db에 최종 반영하는 방법
- migrations 과정은 다음과 같다.  
  - model class -> migration파일 -> db.sqlite3
  - 모델을 변경해도 migration파일을 바꿔야 제대로 적용된다.
  - 핵심 명령어:   
    - 1. python manage.py makemigrations - 모델 클래스를 기반으로 최종 설계도 작성
    - 이때 생성된 것은 절대 수정하면 안된다.
    - 2. python manage.py migrate - 최종 설계도를 db에 전달하여 반영
  - 그리고 db.sqlite3를 확인하면 좌측에 있는 것이 테이블이다.
## migrations 추가
- DateTimeField의 필드 옵션:  
  - auto_now: 데이터가 저장될 때마다 자동으로 현재 날짜시간을 저장
  - auto_now_add : 데이터가 처음 생성될 때만 자동으로 현재 날짜 시간을 저장
- 그리고 클래스를 바뀌면 makemigrations 해주고 또 migrate 해서 db에 넘거야 한다.
- 이때 이미 기존 테이블이 존재하기 때문에 필드를 추가할 때 필드의 기본 값 설정이 필요하다.
- 그러면 1, 2번 중 하나를 선택해야 한다.  
  - 1. 현재 대화를 유지하면서 직접 기본값을 입력하는 방법
  - 2. 현재 대화에서 나간 후 model.py에 기본 값 관련 설정을 하는 방법
- 이때 1번을 선택한 후 아무것도 입력하지 않고 enter를 누르면 장고가 제안하는 기본값으로 설정됨
- 그러면 2번째 설계도가 만들어진다.
- 2번 설계도를 보면 dependencies = [('articles', '0001_initial'),] 이렇게 있는데, 1번 설계도에 의존하는 것이다.
- 마지막에 migrate 후 테이블 필드 변화를 확인해야 한다.
- 과정:  
  - model class 변경 -> makemigrations -> migrate
  - 그리고 절대로 점프는 안된다.
  - 그런데 실습 시 설계도가 꼬였으면 수정하기 보다 설계도를 삭제하고 다시 만드는 것이 더 좋을 수도 있다.
## 관리자 인터페이스
- 장고가 추가 설치 및 설정 없이 자동으로 제공하는 관리자 인터페이스
- 데이터 확인 및 테스트 등을 진행하는데 매우 유용
- 1. admin 계정 생성: python manage.py createsuperuser
- 일단 이름은 admin으로 찍고 나머지는 나중에 해도 된다. 패스워드의 경우 원래 찍어도 안나타난다. 주의하자.
- 그리고 y찍으면 반영 완료
- 2. db에 생성된 admin 계정 확인(새로고침 필수!)
- articles를 admin.py를 활용해서 넣고 페이지를 확인하면 title, content만 나오는데 나머지는 알아서 변경된다.
### 참고
- 데이터베이스 초기화:  
  - 1. 설계도를 삭제해야 한다. 0001, 0002 같은 설계도를 삭제하고 db.sqlite3파일을 삭제해야 한다. 다른거는 삭제하면 안된다.
- showmigtations -> migrations파일들이 migrate 됐는지 안됐는지 여부를 확인
- x 표시가 있으면 migrate가 완료되었음을 의미
- sqlmigrate articles 0001 -> 이거는 해당 migrations 파일이 sql언어로 어떻게 번역되어 db에 전달되는지 확인하는 명령어

## ORM
- 객체 지향 프로그래밍 언어를 사용해 화환되지 않는 유형의 시스템 간에 데이터를 변환하는 기술
- 장고와 db간에 사용하는 언어가 다르기 때문에 소통이 불가능한데 orm이 중간에서 이를 해석해준다.
### queryset api
- orm에서 데이터를 검색, 플터링, 정렬 및 그룹화 하는데 사용하는 도구
- 다음과 같이 구분된다. Article.objects.all()이런데 순서대로 모델 클래스, 매니저, queryset api메서드
- 장고에서 쿼리넷 api로 orm에 보내고 orm에서 쿼리셋이나 인스턴스로 장고로 보낸다.
- 정확한 순서는 다음과 같다.  
  - 1. Article.objects.all()로 orm에 전송
  - 2. 데이터베이스에 sql언어로 전체 게시글을 준다.
  - 3. 데이터베이스에서 sql언어로 orm에 전체 게시글을 받으라고 한다,
  - 4. orm에서 장고로 쿼리셋(전체 게시글 데이터)를 보낸다.
- 쿼리는 데이터베이스에 특정한 데이터를 보여 달라는 요청이다.
- 쿼리문을 작성한다 라고 하는데 원하는 데이터를 얻기 위해 데이터베이스에 요청을 보낼 코드를 작성한다는 뜻이다.
- 쿼리셋은 데이터베이스에게서 전달 받은 객체 목록(데이터 모음)이다.
- 장고 orm을 통해 만들어지는데 단, 데이터베이스가 단일한 객체를 반환할 때는 쿼리셋이 아닌 모델(class)의 인스턴슬 반환된다.
- 결국 쿼리셋 api는 파이썬의 모델 크래스와 인스턴스를 활용해 db에 데이터를 저장, 조회, 수정, 삭제하는 것이다.
- CRUD: 소프트웨어가 가지는 기본적인 데이터 처리 기능 -> 저장, 조회, 갱신, 삭제
- django-extensions, ipython을 추가로 설치해야 하며 settings에 django_extenstions를 추가로 작성해야 한다.
- django shell: 장고 환경 안에서 실행되는 python shell(터미널 이라고 생각하면 된다.) : python manage.py shell_plus
- 그리고 바로 장고 프로젝트에 영향을 준다.
- shell_plus 순서:  
  - 1. article = Article()
  - 2. article.title = 'first'
  - 3. article.content = 'django!'
  - 4. article.save()
  - 이렇게 하면 db.sqlite에 데이터가 생긴다.
  - article.pk는 장고가 추가로 제공하는 기능으로 primary key의 뜻이다. 현재 id를 나타낸다.
  - 두번째 방법:  
    - article = Article(title='second', content='django!')이렇게 한줄에 쓰기
    - 이때 아직 id는 없다.
    - article.save()
    - 이렇게 하면 id가 생긴다. 그리고 데이터가 추가로 생성된다.
- 마지막에 Article.objects.all()를 찍으면 쿼리셋을 받는다.  
    - 세번째 방법:  
      - 1. Article.objects.create(title='third', content='django!')create함수 쓰기
      - 그러면 바로 데이터가 생성된다.
      - 이방법은 save 필요 없다.
      - 그런데 이 방법은 인스턴스를 만든 적이 없다. article = Article() 이런거.
      - article = Article.objects.create(...) 이렇게 했으면 pk가 생긴다.
- save(): 객체를데이터베이스에 저장하는 인스턴스 메서드->Model에 들어가 있음
- 대표적인 조회 메서드:  
  - Return nex QuerySets   
    - all()
    - filter()
  - Do not reutrn QuerySets  
    - get()
  - all(): 전체 데이터 조회
  - filter(): 주어진 매개변수와 일치하는 객체를 포함하는 쿼리셋 반환
  - get(): 주어진 매개변수와 일치하는 객체를 반환 -> pk 조회 할 때만 써라.
  - 고유성을 보장하는 조회에서 사용해야 한다.
- 데이터 수정:  
  - 인스턴스 변수를 변경 후 save메서드 호출
  - 1. 먼저 수정할 인스턴스 조회
  - 2. 인스턴스 변수를 변경
  - 3. 저장
  - 4. 정상적으로 변경된 것을 확인
- 데이터 삭제:  
  - 1. 삭제할 인스턴스 조회
  - 2. article.delete()
### ORM with view
- 장고 쉘에서 연습했던 쿼리셋 api를 직접 view함수에서 사용하기
- 전체 게시글 조회
- **참고**
- 지워진 pk 값은 절대 재사용 안된다. 1,2,3이 있는데 2을 지우면 다음 pk는 4가 나온다.
## Read
- 단일 게시글 조회
## create
- create 로직을 구현하기 위해 필요한 view 함수의 개수는 2개다.
- 사용자 입력 데이터를 받을 페이지를 렌더링
- 사용자가 입력한 요청 데이터를 받아 db에 저장
- <input type="text" name="title" id="title"> 이런 거에서 name이 가장 중요하다.
- 키에 해당 하는 것이 name 이어서 가장 중요
- <label for="title">Title: </label>
  <input type="text" name="title" id="title">
- 여기서 id는 title과 연결
## http request methods
- http: 네트워크 상에서 데이터를 주고 받기 위한 약속
- 데이터에 대한 수행을 원하는 작업을 나타내는 것
- 클라이언트가 웹 서버에 특정 동작을 요청하기 위해 사용하는 표준 명령어
- 대표 메서드: GET, POST
  ### GET 메서드
  - 서버로부터 데이터를 요청하고 받아오는 데 사용
  - 특징:  
    - 1. 데이터 전송 -> url의 쿼리 문자열을 통해 전송송
    - 2. 데이터 제한 -> url길이에 재한이 있어 대량의 데이터 전송 적합 x
    - 3. 브라우저 히스토리-> 요청 url이 브라우저 히스토리에 남음
    - 4. 캐싱 -> 페이지 로딩 시간 단축
  - GET은 결국 검색 쿼리 전송, 웹 페이지 요청, api에서 데이터 조회할 때 쓴다.
### POST
- 서버에 데이터를 제출하여 리소스를 변경(생성, 수정, 삭제) 하는 데 사용
- 특징:  
  - 1. 데이터 전송 -> http body를 통해 전송
  - 2. 데이터 제한 -> FET에 비해 더 많은 양의 데이터를 전송할 수 있음
  - 3. 브라우저 히스토리 -> 브라우저 히스토리
  - 4. 캐싱 -> 기본적으로 캐시 불가능, 이 요청이 일반적으로 서버의 상태를 변경하는 작업을 수행하기 때문이다.
- 로그인 정보 제출
- 파일 업로드
- 새 데이터 생성
- API에서 데이터 변경 요청
- 그래서 GET는 데이터 조회, post는 데이터 생성이나 수정에 주로 사용된다.
## http response status code
- 서버가 클라이언트 요청에 대한 처리 결과를 나타내는 3자리 숫자
- 클라이언트에게 요청 처리 결과를 명확히 전달
- 문제 발생 시 디버깅에 도움
- 웹 애플리케이션의 동작을 제어
### 403 Forbidden
- 서버에 요청이 전달되었지만, 권한 때문에 거절되었다는 것을 의미
- 페이지를 보면 CSRF 토큰이 없다고 뜬다.
### CSRF
- 사이트 간 요청 위조
- 사용자가 자신의 의지와 무관하게 공격자가 의도한 행동을 하여 특정 웹 페이지를 보안에 취약하게 하거나 수정, 삭제 등의 작업을 하게 만드는 공격 방법
- 장고가 직접 제공한 페이지에서 데이터를 작성하고 있는 것이진에 대한 확인 수단이 필요하다. 그래서 csrf token이 필요하다.
## Redirect
- 서버는 데이터 저장 후 페이지를 응답하는 것이 아닌 사용자를 적절한 기존 페이지로 보내야 한다.사용자를 보낸다 -> 사용자가 GET요청을 한번 더 보내도록 해야 한다.
- redirect() -> 클라이언트가 인자에 작성된 주소로 다시 요청을 보내도록 하는 함수
## Delete
- 말 그대로 지우는 파일

## django Form
- html form
- 지금까지 사용자료부터 데이터를 제출 받기 위해 활용한 방법. 그러나 비정상적 혹은 악의적인 요청을 필터링 할 수 없음.
- 유효성 검사 - 수집한 데이터가 정확하고 유효한지 확인하는 과정
- django form
- 사용자 입력 데이터를 수집하고 처리 및 유효성 검사를 수행하기 위한 도구
- Form = 사용자 입력 데이터를 db에 저장하지 않을 때
- modelForm- 사용자 입력 데이터를 db에 저장해야 할 때.
- Meta Class
- 모델 폼의 정보를 작성하는 곳
- 'fields 속성, exclude 속성'
- exclude 속성을 사용하여 모델에서 포함하지 않을 필드를 지정할 수 도 있음
- Meta class 주의사항
- 장고에서 모델 폼에 대한 추가 정보나 속성을 작성하는 클래스 구조를 Meta 클래스로 작성 했을 뿐이며 파이썬의 inner class와 같은 문법적인 관점으로 접근하지 말것
## static files
- 서버 측에서 변경되지 않고 고정적으로 제공되는 파일
- 정적파일은 특정 위치에 있는 자원을 요청 받아서 응답을 처리하고 제공하는 것
- 웹 서버는 요청받은 url로 서버에 존재하는 정적자원을 제공하며 정적파일을 제공하기 위한 경로가 있어야 한다.
### 기본 경로
- app폴더/static/
- articles/static/articles경로에 이미지 파일 배치
- 스태틱 파일 경로는 static tag를 사용해야 한다.
- built-in tag가 아니기 때문에 load tag를 사용해 import 후 사용 가능
- STATIC_URL:  
  - 기본 경로 및 추가 경로에 위치한 정적 파일을 참조하기 위한 url
  - 실제 파일이나 디렉토리 경로가 아니며 url로만 존재
  - URL + STATIC_URL + 정적파일 경로
- static files 추가 경로
- STATICFILES_DIRS에 문자열 값으로 추가 경로 설정
- STATICFILES_DIRS: 정적 파일의 기본 경로 외에 추가적인 경로 목록을 정의하는 리스트
- 결론: 정적 파일을 제공하려면 요청에 응답하기 위한 url이 필요
- Media Files: 사용자가 웹에서 업로드하는 정적 파일
- ImageField(): 이미지 업로드에 사용하는 모델 필드
- 이미지 파일의 경로 문자열이 저장된다.
- 이 필드를 사용하기 위해서는 준비사항이 있다.
- 1. settings.py에 MEDIA_ROOT, MEDIA_URL설정
- 2. 작성한 MEDIA_ROOT 와 MEDIA_URL에 대한 URL지정
- MEDIA_ROOT
- 미디어 파일들이 위차하는 디렉토리의 절대 경로
- media_url: 미디어 루트에서 제공되는 미디어 파일에 대한 주소를 생성
- 그 다음 urls에 지정해야 한다.
- settings의 공식 문서 url을 통해 들어가면 url 찍는 방법이 나온다.
- 절대로 외우는 것 아니다.
- 'Serving files uploaded by a user during development¶'이거 보면 된다.
- 이때 model에 image필드를 추가하는데 기존 필드 사이에 작성해도 실제 테이블 생성 시에는 가장 뒤에 추가된다.
- blank=True 이걸 class의 필드에 추가하면 기본 빈칸으로 지정된다. 
- form요소에 데이터 전송방식을 결정하는 속성인 emctype속성을 추가해야 한다. enctype="multipart/form-data"
- view의 form에 files=request.FILES를 추가해야 한다.
- 똑같은 이미지를 올려도 장고가 자동으로 난수 처리 해준다.
- upload_to: 최종설계도를 만들면 자동으로 생성됨
- 추가 경로를 설정한다.
- 미디어 루트 이후 경로
## Cookie & Session
- 우리가 웹 페이지를 볼때 우리는 서버와 연결되어 있는 상태가 아니다.
- 상태가 없다는 것은 로그인 상태를 유지할 수 없고 장바구니에 담은 상품을 유지할 수 없음.
- http: html문서와 같은 리소스들을 가져올 수 있도록 해주는 규약  
  - 1. 비 연결지향-서버는 요청에 대한 응답을 보낸 후 연결을 끊는다
  - 2. 무상태-연결을 끊는 순간 클라이언트와 서버 간의 통신이 끝나며 상태 정보가 유지되지 않음
- 쿠키: 서버가 사용자의 웹 브라우저에 전송하는 작은 데이터 조각
- 사용자 인증, 추적, 상태 유지 등에 사용되는 데이터 저장 방식
- 서버가 제공하여 클라이언트측에서 저장되는 작은 데이터 파일
- 쿠키 전송 방식:  
  - 클라이언트 서버에 요청 -> 서버가 요청된 페이지와 쿠키를 포함한 응답 보냄 -> 브라우저는 받은 쿠키 저장 -> 다음에 또 보낼때 쿠키를 포함하여 전송 -> 웹 서버는 쿠키 정보 확인. -> 서버는 요청에 대한 응답을 다시 보냄. 이때 기존 쿠키를 수정 할 수 있음
  - 브라우저는 받은 쿠키를 저장해 두엇다가 동일한 서버에 재요청 시 http요청 header의 쿠키 필드에 저장된 쿠키를 함께 전송
- 쿠키 저장 방식:  
  - 브라우저는 쿠키를 key-value형식의 데이터 형식으로 저장
  - 쿠키에는 만료시간, 도메인 ,경로 등의 추가 속성이 포함된다.
- 쿠키의 주요 용도:  
  - 상태가 없는 http프로토콜에서 상태 정보를 기억시켜 주는 역할
  - 두 요청이 동일한 브라우저에서 들어왔는지 아닌지를 판단할 때 주로 사용됨
  - 이를 이용해 사용자의 로그인 상태를 유지할 수 있음
- 쿠키는 서버에 '나 로그인된 사용자야'라는 인증 정보가 담긴 쿠키를 매 요청마다 계속 보내는 것이다.
- 만약 장바구니에 물건들 담고 다른 페이지로 가도 이는 유지된다. 이는 계속 자신이 물건을 담고 있다고 서버에 요청하기 때문이다.
- 쿠키 사용 목적:  
  - 세션 관리
  - 개인화
  - 트래킹
- 세션: 서버 측에서 생성되어 클라이언트와 서버 간의 상태를 유지.
- 상태 정보를 저장하는 데이터 저장 방식이다.
- 쿠키에 세션 데이터를 저장하여 매 요청시마다 세션 데이터를 함께 보냄
- 세션 작동 원리:  
  - 클라이언트가 로그인 요청 후 인증에 성공하면 서버가 세션 데이터(사용자 인증 정보)를 생성 후 저장
  - 생성된 세션 데이터를 인증 할 수 있는 세션 id(열쇠)를 발급
  - 발급한 세션 아이디르 클라이언트에게 응담(데이터는 서버에 저장, 열쇠만 주는 것)
  - 클라이언트는 세션 아이드를 쿠키에 저장
  - 즉, 서버측에서 세션 뎅터를 생성 후 저장하고 이 데이터에 접근할 수 있는 세션 id를 생성, 이 id를 클라이언트 측으로 전달하고 클라이언트는 쿠키에 이 id를 저장, 이후 클라이언트가 같은 서버에 재요청 시마다 저장해 두었던 쿠키도 요청과 함께 전송 
  - 즉 쿠키는 클라이언트에 저장, 세션 자체는 서버에 저장되는 거다.
## Django Authentication System
- 사용자 인증과 관련된 기능을 모아 놓은 시스템
- 인증: 사용자가 누구인지 확인하는 것(신원 확인)
- 사전 준비로 두번째 app인 accounts 생성 및 등록.
- 다른 명을 써도 되기는 하는데 장고 내부적으로 accounts라는 이름을 쓰고 있어서 되도록 'accounts'로 지정하는 것을 권장. 아니면 좀 복잡해진다.
## Custom User Model
- 기존 user model은 auth앱에 작성된 user 클래스를 사용했다. 
- 만약 추가적인 사용자 정보(생년월일, 주소, 나이 등등)가 필요하면 이를 위한 기본 user model를 변경하기 어렵다.
- 그래서 프로젝트의 즉정 요구사항에 맞춰 사용자 모델을 확장할 수 있기 위해 Custom User Model로 대체해야한다.
- AUTH_USER_MODEL: 장고 프로젝트의User를 나타내는 데 사용하는 모델을 지정하는 속성
- 프로젝트 중간에 변경 불가능. 이미 진행되고 있을 경우 데이터베이스 초기화 후 진행
- 만약 프로젝트가 migrate가 되어 있으면 아예 db를 초기화 해야 한다.
- 프로젝트 시작할 때 등록한다.
- accounts앱의 admin에 admin site dp eocpgks  user 모델을 등록해야 한다.
- 왜냐면 기본 User모델이 아니기 때문에 등록하지 않으면 admin 페이지가 출력되지 않는다.

## login
- 로그인은 세션을 create 하는 과정이다.
- AuthenticationForm(): 로그인 인증에 사용할 데이터를 입력받는 내장 form
- get_user(): AuthenticationForm()의 인스턴스 메서드, 유효성 검사를 통과했을 경우 로그인 한 사용자 객체를 반환
- 만약 로그인을 성공 했다면 쿠키가 있을 것이다. f12누르고 application들어가서 cookies에 sessioned가 있는지 확인
- 그리고 db에서 django_session 확인, 있으면 된것
## logout
- 로그아웃은 세션을 delete하는 과정이다.
## Template with Authentication data
- 템플릿에서 인증 관련 데이터를 출력하는 방법
- context_processors: 템플릿이 렌더링 될 때 호출 가능한 컨텍스트 데이터 목록
- 작성된 컨텍스트 데이터는 기본적으로 템플릿에서 사용 가능한 변수로 포함됨

## 회원가입
- User를 create한다.
- UserCreationForm(): 회원가입 시 사용자 입력 데이터를 받는 내장 모델폼이다.
- User 모델을 직접 참조하지 않는 이유는 get_user_model을 사용해 User 모델을 참조하면 커스텀 user모델을 자동으로 반환해주기 때문이다.
- 직접 참조하지 않고 get_user_model을 사용한다.

## 회원탈퇴
## 회원정보 수정
- UserChangeForm(): 회원정보 수정 시 사용자 입력 데이터를 받는 내장함수
## 비밀번호 변경
- 인증된 사용자의 세션 데이터를 업데이트 하는 과정
- PasswordChangeForm()
- 비밀번호가 변경되면 기존 세션과 회원 인증 정보가 일치하지 않게 되어버려 로그아웃 처리 된다.
- 이를 막기 위해서 update_session_auth_hash(request, user)를 써야 한다.
- 필수는 아니다.
## 인증된 사용자에 대한 접근 제한
- 1. is_authenticated속성:  
  - 사용자가 인증 되었는지 여부를 알 수 있는 user model속성
  - 모든 user인스턴스에 대해 항상 True인 읽기 전용 속성
  - 비인증 사용자에 대해서는 항상 False
- 2. login_required 데코레이터
- 인증된 사용자에 대해서만 view 함수를 실행시키는 데코레이터
- view 함수 위에 @login_required를 쓰면 된다.