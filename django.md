# 디장고
- 어떻게 풀기 보다는 어떻게 조합할지에 집중해야 한다.
- 프레임워크를 통해 최종적으로 웹 어플리케이션을 개발한다.
- 프레임워크는 이미 만들어진 도구로 문서와 예제 코드를 보며 활용법을 빠르게 습득하는 것이다.
- 그래서 프레임워크는 조립과 활용에 초점을 맞춘다.
## 웹 어플리케이션 개발
- 인터넷을 통해 사용자에게 제공되는 소프트웨어 프로그램을 구축화는 과정
- 웹의 동장 방식은 클라이언트-서버 구조로 clinet 즉, 우리가 서버에 요청하면 서버가 응답을 하는 구조이다. 이 틀에서 벗어나지 않는다.
- 클라이언트는 사용자의 웹 브라우저, 모바일 앱을 말한다. 그리고 서버는 웹 서버, 데이터베이스 서버를 말한다.
- 조금 자세히 하면 먼저 클라이언트에서 요청을 하면 전 세계 어디에 있는 서버에 파일을 달라고 요청한 것이다. 그리고 해당 서버는 데이터베이스에서 파일을 찾아 응답하고 클라이언트는 전달받은 파일을 사람이 볼 수 있도록 해석해주고 사용자는 구글의 메인페이지를 보게 됨.
- 다시 말하지만 요청-응답은 절대로 변하지 않는 구조이다.
## 프론트엔드, 백엔드
- 프론트엔드는 UI를 구성, 사용자가 어플리케이션과 상호작용 할 수 있도록 한다. 백엔드는 서버측과 동작하며, 클라이언트의 요청에 대한 데이터베이스와의 상호 작용 등을 담당한다.
- 그리고 디장고는 백엔드 즉, 서버 쪽이다.
## 프레임워크
- 웹 프레임워크는 웹 어플리케이션을 빠르게 개발할 수 있도록 도와주는 도구이다. 보통 규칙, 라이브러리 등을 제공한다.
## django framework
- 일단 장고다. 'd' 는 묵음임.
- 이것은 파이썬 기발의 대표적인 웹 프레임워크이다.
- 장고를 사용하는 이유는 다양성, 확장성, 보안, 커뮤니티 지원 기능을 가지고 있기 때문이다.
- 장고는 대규모 프레임워크에서 사용되는데 대표적으로 인스타그램, 드롭박스 같은 것이 있다.
- 그리고 작년 기준으로 장고는 2번째로 인기있는 백엔드 프레임워크이다.
- 그리고 우리는 장고를 사용해 서버를 구현할 것이다.
## 가상환경
- 하나의 컴퓨터 안에서 또 다른 독립된 파이썬 환경
- 예를 들어 한 개발자가 2개의 프로젝트를 진행해야 할 때 2개의 프로젝트를 다른 패키지 버전 사용을 위한 독립적인 개발 환경이 필요할 때 쓰인다. 서로 다른 패키지를 사용하면 충돌이 발생하기에 이를 피하기 위해 독립적인 개발 환경이 필요하며 이 상황에 시나리오가 필요하다.
- 조금 더 비유하면 같은 집(컴퓨터) 안에, 방(가상환경)을 따로 만들어 두고 필요한 물건(라이브러리, 패키지 등)을 그 방에만 들여놓는 것과 비슷.
## 가상 환경 생성 및 활성화
- 1. python - m venv venv: 현 디렉토리에 venv라는 폴더가 생성되고 venv 폴더안에는 파이썬 실행파일, 라이브러리 등을 담을 공간이 마련된다. 
- 또한 이 경우에 venv라는 이름의 가상환경을 생성한 것이며 임의의 이름으로 생성이 가능하나 관례적인 venv 이름을 사용
- 2. 가상환경 활성화
- source venv/Scripts/activate
- 3. 가상환경 종료
- 터미널을 강제 종료 해도 되긴 하는데 비추천
- deactivate 쓰기
- 그러면 원상태로 돌아온다.
## 의존성 패키지
- 프로젝트가 의존하는 개별 라이브러리들을 카리키는 말이다.
- 1. 패키지 목록 확인
- pip list
- 현재 가상환경에 설치된 라이브러리 목록을 확인
- 2. pip freeze > requirements.txt
- 의존성 기록
- 이 파일을 만드면 나중에 동일한 환경을 재현할 때 유용하다.
- 그리고 pip freeze 명령어는 가상환경에 설치된 모든 패키지를 버전과 함께 출력한다.
- 협업 시에도 팀원들이 똑같은 버전의 라이브러리를 설치하도록 공유 가능
- 일단 freeze 먼저 하고 pip freeze > requirements.txt 하기
- 패키지마다 버전이 다르고 프로젝트가 커질수록 사용하는 패키지 개수도 늘어나기 때문에 의존성 리스트를 만들어 어떤 버전을 쓰고 있는지 기록 및 공유가 필수적이다.
- 그리고 무조건 requirements.txt 이 파일명으로 만들어야 한다.
- 3. 의존성 패키지 기반 설치
- pip install -r requirements.txt
- 이 명령어를 쓰면 해당 텍스트에 기록된 패키지와 버전을 읽어와 같은 환경으로 설치한다.
- 라이브러리 설치 순서는 없긴 한데 간혹 가이드문서에 이 순서대로 설치하라고 뜨면 그대로 설치하면 된다.
- 4. 가상환경 주의사항
- 가상환경에 "들어오고 나오는" 것이 아니라 사용할 파이썬 환경을 "on/off"로 전환하는 개념
- venv의 환경에서 상위로 가도  venv는 꺼지지 않는다.
- 그런데 새 터미널 창을 열면 다시 활성화 해야 한다.
- 프로젝트마다 별도의 가상환경을 사용
- 일반적으로 가상환경 폴더 venv는 관련된 프로젝트와 동일한 경로에 위치시킴.
- 폴더venv는 .gitignore파일에 작성되어 원격저장소에 공유되지 않도록 해야 한다.
- 5. 가상환경이 필요한 이유
- 프로젝트마다 다른 버전의 라이브러리를 사용하고 의존성 충돌을 방지하며 팀원 간 협업을 위해 필요하다.
- 필수과정 요약:  
  - 1. 가상환경을 만든다
  - 2. 가상환경을 활성화한다.
  - 3. 필요한 의존성 패키지를 설치
  - 4. 현재 환경의 모든 패키지목록을 저장하여 의존성 관리
  - 5. 다른 컴퓨터나 팀원도 필요하다면 동일한 버전의 라이브러리를 설치
  - 6. 작업이 끝나면 deactive로 가상환경을 비활성화
## 프로젝트 생성
- django-admin startproject firstpjt . 이때 startproject까지는 무조건 외우기. 다음은 파일 이름
- python manage.py runserver: manage.py와 동일한 위치에서 명령어 진행
- 서버 확인
## 디자인 패턴
- 소프트웨어 설계에서 발생하는 문제를 해결하기 위한 일반적인 해결책
- 어플리케이션 구조는 이렇게 구성하자 라는 관행
- MVC 디자인 패턴:  
  - 데이터, 사용자 인터페이스, 비즈니스 로직을 분리한다.
  - (model, view, controller)
- 그런데 장고에서는 구조는는 같지만 이름을 바꿔서 부름
- MTV 디자인 패턴:  
  - (model, template, view)
  - 기존 mvs패턴과 동일하나 단순히 명칭을 다르게 정의한 것
  - 단순히 명칭만 변경
## 프로젝트와 앱
- 프로젝트 안에 앱이 여러개 있고 이것이 프로젝트를 구성한다.
- 만약 온라인 커뮤니티 카페를 만든다면 카페가 프로젝트이며 앱은 게시글, 댓글, 회원 관리라고 할 수 있다.
- 앱을 사용하기 위해서는 앱을 생성하고 앱을 등록해야 한다.
- 앱 생성:  
  - python manae.py startapp articles
  - 앱의 이름은 복수형으로 지정하는 것을 권장
- 앱 등록:  
  - 반드시 앱을 생성한 후에 등록해야 한다.
  - installed_apps에 'articles', 를 등록해야 한다.
## 프로젝트 및 앱 구조
- settings.py, urls.py, __init__.py, asgi.py, wsgi.py, manage.py
- 그런데 수정하는 것은 settings.py, urls.py 이렇게 2개 뿐이다. 나머지는 수정 안한다.
- 앱에서는 3개만 보면 된다. admin.py, models.py, views.py 
- 나머지는 수정 안한다.
## 요청과 응답
- 순서:  
  - 요청 -> urls.py -> views.py <-> (models.py, temlplates) -> 응답
- url경로는 반드시 '/'(slash로 끝나야 한다.)
## django temlate system
- 데이터 표현을 제어하면서 표현과 관련된 부분을 담당
- DTL: template에서 조건, 반복, 변수 등의 프로그래밍적 기능을 제공  
  - 1. variable: render함수의 세번째 인자로 딕셔너리 데이터 사용  
    - 딕셔너리 키에 해당하는 문자열이 template에서 사용 가능한 변수명이 된다.
    - {{variable}}
  - 2. filters: 표시할 변수를 수정할 때 사용(변수 | 필터)  
    - 연결이 가능하며 일부 필터는 인자를 받기도 한다.
    - 60개의 빌트인 필터 제공
    - {{variable|filter}}
  - 3. tags: 반복, 또는 논리를 수행하여 제어 흐름을 만든다.   
    - 일부 태그는 시작과 종료 태그가 필요
    - 24개의 빌트인 템플레이트 태그 제공
    - {% tag %}
  - 4. comments(주석)   
    - {%comment%}   
    - ...   
    - {%endcomment}   
    - 이런식으로 주석을 처리한다.
    - {#name#} 이런 식으로 단일 주석도 있다.
- 공식문서에서 사용법 등을 찾아야 하는데 사이트에서 찍는 것은 비추천
- django document 하고 다음에 필요한 것 예를 들면 list 이런 식으로 나열하고 검색
- 나오는 결과 중 알맞는 것 찾아서 보기
## 템플릿 상속:  
- 페이지의 공통 요소를 포함하고 기본 스켈레톤 템플릿을 작성하여 상속 구조를 구축
- block으로 범위를 지정한다.
- extends tag: {5 extends 'path' %}
- 자식 템플릿이 부모 템플릿을 확장한다는 것을 알림
- 반드시 자식 템플릿 최상단에 작성되어야 하고 2개 이상 사용 불가
- block tag: {%block name%} {%endblock name%}
- 하위 템플릿에서 재정의 할 수 있는 블록을 정의
- 상위 템플릿에 작성하며 하위 템플릿이 작성할 수 있는 공간을 지정하는 것
## 요청과 응답
- form tag: http 요청을 서버에 보내는 가장 편리한 방법
- form, input이 제일 중요. form은 외각, input은 받는 것
- 사용자로부터 할당된 데이터를 서버로 전송
- 우리가 검색하면 키로 받는다.
- 핵심은 query, 그리고 input에 name 이 없으면 검색 안됨
- action & method: 데이터를 어디(action)로 어떤 방식(method)으로 요청할지
- method에서 데이터를 어떤 방식으로 보낸 것인지 정의하는데 get, post가 있는데 get이 기본
- get: 검색, 조회
- post: 삭제, 수정, 생산 ...
- input: 사용자의 데이터를 입력 받는 요소로 핵심 속성은 name이다.
- name은 사용자가 입력한 데이터에 붙이는 이름(key)이다.
- 문자열은 &로 연결된 key-value로 연결, 기본 url과는 물음표(?)로 구분된다.
- 그리고 submit이 없으면 전송 안됨
- request.GET.get('message') 이게 request 객체에서 form 데이터 추출
## 장고 urls
- url dispatcher
- url 패텬을 정의하고 해당 패턴이 일치하는 요청을 처리할 view 함수를 연결
- 템플릿이 많은 부분이 중복되게 된다. 이를 해결하기 위한 방법이 variable routing 이다.
- url 일부에 변수를 포함시키는 것이다.
- 작성법: <path_converter:variable_name> 타입: 변수명
- path('articles/<int:num>/', views.detail)
- inclue(): 프로젝트 내부 앱들의 url을 참조할 수 있도록 매핑하는 함수
- from django.urls import path, include
- path('articles/', include('articles.urls'))
## url 이름 지정
- 기존 articles/ 주소가 articles/index/로 변경되면 해당 urlㅇㄹ 사용하는 모든 위치를 찾아가 변경해야 한다. 그래서 name을 사용해 url에 이름을 지정해준다
- naming url patterns: url에 이름을 지정
- path('articles/', views.detail, name='index 이렇게')
- 그러면 url을 작성하는 모든 곳에서 변경되는데 a와 form의 주소 쓰는데서 전부 바뀐다.
- {%url 'dinner'%} 이렇게
## url 이름 공간
- 만약 두 앱의 url 이름이 같으면 url 맨 위에 app_name = "name" 이렇게 app_name을 맨 위에 써야 한다.
## Model
- db의 테이블을 정의하고 데이터를 조작할 수 있는 기능들을 제공
- 테이블 구조를 설계하는 청사진
- 우리가 파이썬으로 보내면 장고가 sql로 바꿔줌
- 보통 프로젝트나 어플을 만들었을 때 기본적으로 import되어 있는 것은 무조건 쓰게 될 것 이라는 뜻.
- class Article(models.Model): 여기서 Model에 대한 모든 정보를 가지고 온다.
- django.db.models모듈의 Model이라는 부모 클래스를 상속받는다.
- Model은 model에 관련된 모든 코드가 이미 작성되어 있는 클래스
- 개발자는 가장 중요한 테이블 구조를 어떻게 설계할지에 대한 코드만 작성하기 위한 것이다.
- 상속을 활용한 프레임워크의 기능 제공
- 다음 줄의 title, content 같이 클래스의 변수명은 '필드'라고 부른다.
- 그리고 charfield, textfield는 model field로 데이터베이스 테이블의 열을 나타내는 중요한 구성요소이며 데이터의 유형과 제역 조건을 정의한다.
- title = models.CharField(max_length=10) 여기서 field는 데이터 타입을 결정한다. 그리고 클래스 상속, max_length=10 -> 10글자가 최대다. 그리고 이 옵션이 필수다.
- 헷갈리면 클래스 다시 복습하기!
- content = models.TextField() 이 코드의 TextField와 CharField의 기능은 다르다.
## Model Field
- db 테이블의 필드(열)을 정의하며, 해당 필드에 저장되는 데이터 타입과 제약 조건을 정의
- Field types(필드 유형):  
  - 데이터베이스에 저장될 데이터의 종류를 정의
  - charfield(): 제한된 길이의 문자열을 저장. 그래서 필드의 최대 길이를 결정하는 max_length는 필수 옵션이다.
  - textfield(): 길이 제한이 없는 대용량 텍스트를 저장하는데 무한대는 아니고 사용하는 시스템에 따라 달라진다.
  - 주요 필드 유형:  
    - 문자열 필드: charfield, textfield
    - 숫자 필드: integerfield, floatfield
    - 날짜/시간 필드: datefield, timefield, datetimefield
    - 파일 관련 필드: filefield, imagefield
    - 위의 필드들은 자주 쓰이는 필드 이다.
- Field Options(필드 옵션):  
  - 필드의 동작과 제약 조건을 정의
  - 위의 charfield에서 max_length가 필드 옵션
  - 제약조건: 특정 규칙을 강제하기 위해 테이블의 열이나 행에 적용되는 규칙이나 제한사항
  - 주요 필드 옵션:  
    - null: 데이터베이스에서 null값을 허용할지 여부를 결정
    - blank: form에서 빈 값을 허용할지 여부를 결정
    - default: 필드의 기본값을 설정
## Migrations
- 모델 클래스의 변경사항을 db에 최종 반영하는 방법
- migrations 과정은 다음과 같다.  
  - model class -> migration파일 -> db.sqlite3
  - 모델을 변경해도 migration파일을 바꿔야 제대로 적용된다.
  - 핵심 명령어:   
    - 1. python manage.py makemigrations - 모델 클래스를 기반으로 최종 설계도 작성
    - 이때 생성된 것은 절대 수정하면 안된다.
    - 2. python manage.py migrate - 최종 설계도를 db에 전달하여 반영
  - 그리고 db.sqlite3를 확인하면 좌측에 있는 것이 테이블이다.
## migrations 추가
- DateTimeField의 필드 옵션:  
  - auto_now: 데이터가 저장될 때마다 자동으로 현재 날짜시간을 저장
  - auto_now_add : 데이터가 처음 생성될 때만 자동으로 현재 날짜 시간을 저장
- 그리고 클래스를 바뀌면 makemigrations 해주고 또 migrate 해서 db에 넘거야 한다.
- 이때 이미 기존 테이블이 존재하기 때문에 필드를 추가할 때 필드의 기본 값 설정이 필요하다.
- 그러면 1, 2번 중 하나를 선택해야 한다.  
  - 1. 현재 대화를 유지하면서 직접 기본값을 입력하는 방법
  - 2. 현재 대화에서 나간 후 model.py에 기본 값 관련 설정을 하는 방법
- 이때 1번을 선택한 후 아무것도 입력하지 않고 enter를 누르면 장고가 제안하는 기본값으로 설정됨
- 그러면 2번째 설계도가 만들어진다.
- 2번 설계도를 보면 dependencies = [('articles', '0001_initial'),] 이렇게 있는데, 1번 설계도에 의존하는 것이다.
- 마지막에 migrate 후 테이블 필드 변화를 확인해야 한다.
- 과정:  
  - model class 변경 -> makemigrations -> migrate
  - 그리고 절대로 점프는 안된다.
  - 그런데 실습 시 설계도가 꼬였으면 수정하기 보다 설계도를 삭제하고 다시 만드는 것이 더 좋을 수도 있다.
## 관리자 인터페이스
- 장고가 추가 설치 및 설정 없이 자동으로 제공하는 관리자 인터페이스
- 데이터 확인 및 테스트 등을 진행하는데 매우 유용
- 1. admin 계정 생성: python manage.py createsuperuser
- 일단 이름은 admin으로 찍고 나머지는 나중에 해도 된다. 패스워드의 경우 원래 찍어도 안나타난다. 주의하자.
- 그리고 y찍으면 반영 완료
- 2. db에 생성된 admin 계정 확인(새로고침 필수!)
- articles를 admin.py를 활용해서 넣고 페이지를 확인하면 title, content만 나오는데 나머지는 알아서 변경된다.
### 참고
- 데이터베이스 초기화:  
  - 1. 설계도를 삭제해야 한다. 0001, 0002 같은 설계도를 삭제하고 db.sqlite3파일을 삭제해야 한다. 다른거는 삭제하면 안된다.
- showmigtations -> migrations파일들이 migrate 됐는지 안됐는지 여부를 확인
- x 표시가 있으면 migrate가 완료되었음을 의미
- sqlmigrate articles 0001 -> 이거는 해당 migrations 파일이 sql언어로 어떻게 번역되어 db에 전달되는지 확인하는 명령어