# WEB
- 웹은 웹 사이트, 웹 어플리케이션 등을 통해 사용자들이 정보를 검색하고 상호 작용하는 기술이다.
- 웹 사이트는 여러개의 웹페이지가 모인 것이고 사용자들에게 정보나 서비스를 제공하는 공간이다.
- 웹페이지는 HTML, CSS등의 웹 기술을 이용하여 만들어진 웹사이트를 구성하는 하나의 요소이다.
- 웹 페이지는 구조, 스타일링, 행동으로 구성되는데 각각 HTML, CSS, JAVASCRIPT가 그 역할을 수행한다.
- HTML은 웹 페이지의 의미와 구조를 정의하는 언어이다.
- 이때 H는 Hypertext인데 이는 웹 페이지를 다른 페이지로 연결하는 링크이다.
- 이의 특징은 비선형성, 상호연결성, 사용자 주도적 탐색이다.
- 그리고 ML은 Markup Language인데 태그 등을 이용하여 문서나 데이터의 구조를 명시하는 언어를 뜻한다.  
  - 예시: HTML, Markdown
## HTML
- HTML 구조:  
  - <!DOCTYPE html>: 해당 문서가 html로 문서라는 것을 나타낸다.
  - <html></html>: 전체 페이지의 콘텐츠를 포함
  - <title></title>: 브라우저 탭 및 즐겨찾기 시 표시되는 제목으로 사용
  - head, body로 구조된다.
  - <head></head>: HTML 문서에 관련된 설명, 설정 등 컴퓨터가 식별하는 메타데이터를 작성
  - 사용자에게는 보이지 않는다.
  - <body></body>: HTML문서의 내용을 나타낸다. 페이지에 표시되는 모든 콘텐츠를 작성하며 한 문서에 하나의 body요소만 존재한다.
  - HTML Element(요소): 하나의 요소는 여는 태그와 닫는 태크 그리고 그 안의 내용으로 구성됨.
  - 닫는 태그는 태그 이름 앞에 슬래시가 포함된다. 그런데 닫는 태그가 없는 태그도 있긴 하다.  
    - <p> 이렇게 열과 </p>이렇게 닫는 태그 앞에는 슬래시가 포함된다.
- HTML Attributes(속성): 사용자가 원하는 기준에 맞도록 요소를 설정하거나 다양한 방식으로 요소의 동작을 조절하기 위한 값
- 목적: 나타내고 싶지는 않지만 추가적인 기능, 내용을 담고 싶을 때, CSS에서 스타일 적용을 위해 해당 요소를 선택하기 위한 값으로 활용된다.
- 속성 작성 규칙:  
  - 속성은 요소이름과 속성 사이에 공백이 있어야 한다.
  - 하나 이상의 속성들이 있는 경우엔 속성 사이에 공백으로 구분해야 한다.
  - 속성 값은 열고 닫는 따옴표로 감싸야 한다.
- html을 만들 때 코드에 !쓰고 엔터 치면 기본 구조가 작성된다.  
- 요소가 큰거고 속성은 그 안에 있다!
  - <!DOCTYPE html>  
    <html lang="en">  
    <head>  
      <meta charset="UTF-8">  
      <meta name="viewport" content="width=device-width, initial-scale=1.0">  
      <title>Document</title>  
    </head>  
    <body>  
  
    </body>  
    </html>  
  - 이런식으로 작성된다. 
- html에서 body가 안적혀 있으면 웹페이지에 아무것도 안보인다. title은 웹 페이지의 이름이어서 맨 위에 뜬다.
- <P>: 이건 글자 삽입하는거
- <a herf="">abcd</a> : 이렇게 하면 abcd가 링크 누르는 것으로 작성됨. herf의 ""안에 사이트를 넣어야 링크를 눌렀을 때 그곳으로 넘어간다.
- 닫는 슬래시가 없는 것은 대표적으로 이미지 인데, 이미지는 닫을 필요가 없다. 이미지는 경로를 작성하면 된다.
- src의 ""안에 경로를 넣으면 그 경로 안의 이미지가 웹페이지에 나온다.
- alt다음에 ""안에 글을 넣으면 대체 택스트가 나온다. src가 문제가 생겼을 때 대체할 텍스트다.
- 해당 페이지에서 마우스 우클릭 하고 검사를 누르면 개발자 도구가 나온다. 여기에 우리가 작성한 소스코드가 나온다. ctrl + shift + i로도 열린다.
- 여기서 수정, 디버깅 가능
- <h1>heading</h1>: 이거는 단순히 텍스트를 크게 만드는 것이 아니라 현재 문서의 최상위 제목이라는 의미를 부여하는 것이다. 번호가 커질수록 글자 크기 작아짐
- 대표적인 html 텍스트 스트럭쳐는 다음과 같다.:  
  - Heading & Paragraphs: h1-6, p
  - Lists: ol - 들여쓰기 안되어 있는 대표 문자, ul - 기능은 li와 같은데 번호가 없음, li - 들여쓰기해서 순차적으로 번호 나옴  
    - <ol>  
      <li>파이썬</li>  
      <li>알고리즘</li>  
      <li>웹</li>  
    </ol>
    - 이런식으로 되어 있음
  - Emphasis & Importance: em - 기울이기, strong - 볼드처리
## CSS
- Cascading Style Sheet
- 웹페이지의 디자인과 레이아웃을 구성하는 언어
- html은 좌측상단부터 쌓아 나간다.
- css는 이미지나 태그를 이동시켜준다. css가 할 일이 아주 많다.
- css 구문:  
  - h1 - 선택자(Selector){
  - color: red; - 선언(Declaration)
  - front-size - 속성(property): 30px; - 값(value)
  - }
  - 선언의 끝에는 꼭 세미콜론을 써야 한다.
- 웹 스타일링:  
  - 인라인 스타일: html요소 안에 style속성 값으로 작성
  - 내부 스타일 시트: head 태그 안에 style태그에 작성. 이쪽이 훨씬 더 보기 좋음. 주로 내부를 쓸 것임
  - 외부 스타일 시트: 별도 css파일 생성 후 html link태크를 사용해 불러오기. 이거는 좀 정신 없음. 너무 왔다갔다 함.
## CSS Selectors
- 이게 제일 중요
- html요소를 선택하여 스타일을 적용할 수 있도록 하는 선택자
- 종류:  
  - 기본 선택자:  
    - 전체(*) 선택자: html모든 요소를 선택
    - 요소(tag) 선택자: 저장한 모든 태크를 선택
    - 클래스(class) 선택자: 주어진 클래스 속성을 가진 모든 요소를 선택('.'(dot)), 가장 많이 쓴다.
    - 아이디(id) 선택자: (#) 주어진 아이디 속성을 가진 요소 선택, 문서에는 주어진 아이디를 가진 요소가 하나만 있어야 한다.
    - 속성(attr) 선택자 등
  - 결합자(combinators)  
    - 자손 결합자(" "(space)): 첫번째 요소의 자손 요소들 선택, p span은 <p>안에 있는 모든 <span>을 선택, 하위레벨 상관 없다.
    - 자식 결합자(">"): 첫번째 요소의 직계 자식만 선택, ul > li은 <ul>안에 있는 모든 <li>를 선택. 한단계 아래 자식들만.
    - 자식이라는 것은 그 컨텐츠 안에 들어가 있어야 한다.
    - <p> 여기 안에 있어야 자식이다. </p>
- 명시도: 결과적으로 요소에 적용한 CSS선언을 결정하기 위한 알고리즘
- CSS Selector에 가중치를 계산하여 어떤 스타일을 적요할지 결정.
- 동일한 요소를 가리키는 2개 이상의 CSS규칙이 있는 경우 가장 높은 명시도를 가진 Selector가 승리하여 스타일이 적용됨
- Casecade(계단식)
- 한 요소에 동일한 가중치를 가진 선택자가 적요될 때 CSS에서 마지막에 나오는 선언이 사용됨.
- 명시도 높은 순:  
  - 좁은 범위를 선택할수록 명시도가 높다.  
    - 1. importance: (!importance) 이렇게 쓴다.
    - 2. inline 스타일
    - 3. 선택자: id> class > 요소, 클래스를 99% 쓸것이다.
    - 4. 소스코드 선언순서
- !important: 다른 우선순위 규칙보다 우선하여 적용하는 키워드. 강제로 스타일을 적용하는 방식이어서 사용 권장 않함.
- CSS 상속
- 기본적으로 CSS는 상속을 통해 부모 요소의 속성을 자식에게 상속해 재사용성을 높임.
- 크게 2가지로 나뉜다.  
  - 상속 되는 속성: Text 관련 요소(font, color, text-align), opacity, visibility등 
  - 상속 되지 않는 속성: Box model 관련 요소(width, height, border, box-sizing), position 관련 요소(positoin, top/right/bottom/left, z-index) 등
## CSS Box Model
- 웹 페이지의 모든 html요소를 감싸는 사각형 상자 모델
- 모든 요소는 네모난 박스로 되어 있으며 원은 네모 박스를 깎은 것이다.
- 박스 타입:  
  - 1. Block box
  - 2. Inline box
- 박스 표시 타입  
  - 1. Outer display type: 박스가 문서 흐름에서 어떻게 동작할 지를 결정, 속성: blck, inline    
    - block 특징:  
      - 항상 새로운 행으로 나뉜다.
      - width, height 속성 사용 가능
      - h1 - 6, p, div가 대표적
    - inline 특징:  
      - 1. 새로운 행으로 넘어가지 않는다.
      - 2. 수직, 수평방향으로 나뉜다.
      - 3. 수직방향: padding, margin, border 수평방향: padding, margins, borders적용용
      - 4. a, img, span, strong, em 등등
  - 2. inner display type: 박스 내부의 요소들이 어떻게 배치될지를 결정, 속성: flex
  - 3. normal flow: 일반적인 흐름 또는 레이아웃을 변경하지 않은 경우이다. 웹 ㅍ에이지 요소가 배치되는 방식임.
- html은 연속된 공백을 하나로 처리한다.
- 엔터키로 줄 바꿈을 해도 브라우저에서 인식하지 않는다. 줄 바꿈 태그를 사용해야 한다.
- 에러가 있어도 별도의 에러 메세지를 출력하지 않는다.
- 소문자 사용 강력 권장
- 속성 값에는 큰 따옴표를 사용하는 것이 일반적
- 클래스 선택자를 우선적으로 사용한다
- id, 요소 선택자 등은 가능한 필할 것. 
- 속성과 값은 소문자로 작성.
- 0값에는 단위를 붙이지 않는다.
- 클래스 이름은 의미있고 목적을 나타내는 이름을 사용한다.
- 약어보다는 전체 당어를 사용
- 케밥케이스를 사용한다.
- css의 모든 속성은 외우는 것이 아니고 필요할 때마다 검색해서 학습 후 사용할 것
## MDN
-  mdn web docs
-  웹 개발자와 디자이너를 위한 종합적인 참고자료.
-  검색할 때 검색할 이름을 쓰고 그 뒤에 mdn을 붙여 검색을 먼져 하기
## CSS Box Model 2
- 각 방향이 있는데 좌상부분에서 top이 있고 오른쪽 방향이다. 바텀은 대각선 방향에 있고 반대 방향이다.
- right는 우상부분에 있고 아래 방향이다, left는 대각선 반대편에 있고 위쪽이다.
- 내용(content), 안쪽여백(padding), 테두리(border), 외부간격(margin)으로 구성되어 요소의 크기와 배치를 결정한다.
- content box, padding box, border box, margin box로 이루어 진다.
- 안쪽부터 content, padding, border, margin 이다.
- shothand 속성 - border, 작성 순서에는 영향을 주지 않는다.
- 마진과 패딩 순서- 4개:상우하좌 3개: 상/좌우/하, 2개: 상하/좌우, 1개: 공통
- 표준 상자 모델에서 width와 height속성 값을 성정하면 이 값은 컨텐트 박스의 크기를 조정하게 된다.
- CSS는 보더 박스가 아닌 컨텐트 박스의 크기를 width값으로 지정한다.
- 그래서 컨텐트 박스 기준으로 하지 않을 때는 box-sizing: border-box 이렇게 해서 보더 박스의 크기를 변경한다고 해야 한다.
- inline-block: 인라인과 블록 요소 사이의 중간 지점을 제공하는 디스플레이 값  
  - width, height 속성 사용 가능
  - 패딩, 마진 및 보더로 인해 다른 요소가 상자에서 밀려남
  - 새로운 행으로 넘어가지 않음
  - 이걸 쓰면 가운데 정렬이 되고 테두리의 선 중 하나가 안보여도 보이게 된다.
  - display: inline-block 이런식으로 쓴다.
- none: 요소를 화변에 표시하지 않고, 공간조차 부여되지 않음.  
  - class="box none" 이런식으로 쓰인다.
  - 코드에는 있지만 당장은 필요가 없을 때, none을 써서 안보이게 만든다.

## CSS position
- 요소를 노멀플로우에서 제거하여 다른 위치로 배치하는 것
- 다른 요소 위에 올리기, 화면의 특정 위치에 고정시키기 등 가능
- CSS layout  
  - 각 요소의 위치와 크기를 조정하여 웹 페이지의 디자인을 결정
  - display, position, flexbox
- 포지션은 4 방향 이동이 가능하다. top, bottom, left, right, Axis(z축) 이렇게 가능하다.
- position 유형  
  - static- 이거는 기본 상태. 현재 상태다.  
    - 요소를 노멀 플로우에 따라 배치
    - top, bottom, left, right 속성 적용되지 않음
    - 기본값값
  - relative  
    - 요소를 노멀 플로우에 따라 배치
    - 자신의 원래 위치를 기준으로 이동
    - top, bottom, left, right속성으로 위치를 조정
    - 다른 요소의 레이아웃에 영향을 주지 않음
  - absolute  
    - 요소를 노멀플로우에서 제거
    - 가장 가까운 relative 부모 요소를 기준으로 이동
    - 만족하는 부모 요소가 없다면 body 태크를 기준으로 한다
    - top, bottom, left, right 속성으로 위치를 조정
    - 문서에서 요소가 차지하는 공간이 없어짐
    - 영상 밑에 영상길이 나타내는 것이 있는데 그것이 absolute를 사용한 것
  - fixed  
    - 요소를 노멀플로우에서 제거
    - 현재 화면영역을 기준으로 이동
    - 스크롤해도 항상 같은 위치에 유지됨
    - top, bottom, left, right 속성으로 위치를 조정
    - 문서에서 요소가 차지하는 공간이 없어짐
    - 화면에서 '모바일 버전으로 보기', '설정' 같은 표시는 fixed이다.
  - sticky  
    - relative와 fixed의 특성을 결합한 속성
    - 스크롤 위치가 임계점에 도달하기 전에 relative처럼 동작
    - 스크롤이 특정 임계점에 도달하면 fixed처럼 동작하며 화면에 고정됨
    - 만약 다음 스티키 요소가 나오면 당므 스티키 요소가 이전 스티키 요소의 자리를 대체
    - 이전 스트키 요소가 고정되어 있던 위치와 다음 스트키 요소가 고정되어야 할 위치가 겹치게 되기 때문
    - 위에 닿는 순간 고정되고 다음 스트키가 오면 그것으로 대체된다.
- .relative {
      /* top은 아래쪽이다. 실제 이동하는 것은 반대 방향이다. */
      /* 아래 코드는 우하향으로 간것이다. */
      position: relative;
      background-color: lightblue;
      top: 100px;
      left: 100px;
    }
- z-index:  
  - 기본값은 auto이고 부모 요소의 z-index값에 영향을 받는다.
  - 같은 부모 내에서만 z-index값을 비교한다.
  - 요소의 쌓임 순서를 정의한다.
  - 정수 값을 사용해 z축 순서를 지정한다.
  - 값이 클수록 요소가 위에 쌓이게 된다.
  - 만약 z-index가 3,2,1이 있을 때 3이 z축에서 위여서 제일 위에 위치된다.
- 포지션 목적:  
  - 전체 페이지에 대한 레이아웃을 구성하는 것보다는 페이지 특정 항목의 위치를 조정하는 것.
  - 너무 크게 사용할 필요는 없다.
## CSS Flexbox
- 전체를 담당한다.
- 요소를 행과 열 형태로 배치하는 1차원 레이아웃 방식 -> 공간배열, 정렬
- flex container - 주체, flex item, main axis - 가로선, main start, main end 이 두개는 세로 cross axis - 세로선 cross end, corss start. 이거는 가로
- main axis:  
  - flex item들이 배치되는 기본 축.
  - main start에서 시작해서 end 방향으로 배치
- flex container:  
- 이 컨테이너의 1차 자식 요소들이 flex item이 된다. 
- flexbox속성 값들을 사용하여 자식 요소 flex item들을 배치하는 주체
- 플랙스 컨테이너 속성: display, flex-dirction ...
- 플랙스 아이템 관련 속성: align-self, flex-grow, order, flex-basis  

- flex-direction
- flex-item이 나열되는 방향을 지정
- 메인 축만 기억하면 된다. row일 경우 세로로, column일 경우 가로로 길게 배치된다.  

- flex-wrap
- flex item 목록이 flex container의 한 행에 들어가지 않을 경우 다른 행에 배치할지 여부 설정  

- justify-content 주 축을 따라 flex item과 주위에 공간을 구배
- justify-content: center; 이거 가운데 정렬  

- align-content
- 교차 축을 따라 flex item과 주위 공간을 분배
- flex-wrap이 wrap또는 wrap-revers로 설정된 여러 행에만 적용됨
- 한줄짜리 행에는 효과 없음.  

- align-items
- 교차 축을 따라 flex item 행을 정렬  
- 
- align-self
- 교차 축을 따라 개별 flex-item을 정렬  

- 목적에 따른 속성 분류:  
  - 배치:  
    - flex-direction, flex-wrap
  - 공간 분배:  
  - justify-content, align-content
- 정렬:  
  - align-items, align-self
- justify:주축, align:교차축
- 그런데 justify-items,self속성은 없는데 margin으로 정렬 및 배치가 가능하기 때문이다.

- flex-grow:  
  - 남는 행 여백을 비율에 따라 각 flex item에 분배
  - 만약 100, 100, 100, 100, 200 이때 200은 비어 있음
  - 앞의 4개에 1, 1, 0, 2 이렇게 주면
  - 150, 150, 100, 20 이렇게 되는데 남은 200을 값 (1+1+0+2)로 나누면 50이 되고 
  - 정해진 숫자 만큼 50을 더해준다. 그래서 100+50, 100+50, 100, 100+100
- flex-basis는 flex item의 초기 크기 값을 지정하는데 width와 동시에 적용한 경우, basis가 우선이다.
- 반응형 레이아웃
- 다양한 디바이스와 화면 크기에 자동으로 적응하여 콘텐츠를 최적으로 표시하는 웹 레이아웃 방식
- flex-wrap을 사용해 반응형 레이아웃을 작성한다.
- 마진 상쇄:
- 두 블록 타입 요소의 마진 탑과 바텀이 만나 더 큰 마진으로 결합되는 형상
- 복잡한 레이아웃에서 요소 간 간격을 일관 되게 유지하기 위함
- 요소 간의 간격을 더 예측 가능하고 관리하기 쉽게 만든다.
- 일관성, 단순화
## Bootstrap
- css 프론트엔트 프레임워크로 미리 만들어진 다양한 디자인 요소들을 제공하여 웹 사이트를 빠르고 쉽게 개발할 수 있도록 한다.
- CDN: 지리적 제약 없이 빠르고 안전하게 콘텐츠를 전송할 수 있는 전송 기술
- 서버와 사용자 사이의 물리적인 거리를 줄여 콘텐츠 로딩에 소요되는 시간을 최소화.
- 지리적으로 사용자와 가까운 CDN 서버에 콘텐츠를 저장해서 사용자에게 전달
- bootstrap.min.css 이걸 보면 min이 있는데 이게 있으면 압축되어 있는 것이다.
- 이것으로 몇천줄 짜리를 가져온 것이다.
- 그리고 다운로드 받은 것 중 밑부분은 기능을 세부적으로 분할해 둔 거여서 위의 파일에 그 기능이 전부 있다.
- 기본 사용법:  
  - mt - 5 = 마진 탑 5는 아직알 수 없음
  - {property}{sides}-size
  - 클래스 이름 spacing 표현법:  
    - sides:
    - t: top
    - b: bottom
    - s: left
    - e:right
    - y: top, bottom
    - x: left, right
    - blank:4 sides
    - size:
    - 0 0rem 0px
    - 1 0.25rem 4px
    - 2 0.5rem 8px
    - 3 1rem 16px
    - 4 1.5rem 24px
    - 5 3rem 48px
    - auto auto auto
- bootstrap에는 특정한 규칙이 있는 클래스 이름으로 스타일 및 레이아웃이 미리 작성되어 있음
## reset css
- 모든 html 요소 스타일을 일관된 기준으로 재설정하는 간결하고 압축된 규칙 세트
- 부트스트랩을 사용 하면 기존 볼드 되어있던것이 기본 형태로 돌아간다.
- 이 볼드 처리 되는 이유는 각 브라우저 마다 useragent stylesheet를 가지고 있는데 이 설정이 다 상이하기 때문이다.
- 이렇듯 모든 브라우저에서 웹사이트를 동일하게 보이게 만드는 것은 개발자에게 골치아프다.
- 그래서 모두 똑같은 스타일 상태로 만들고 스타일 개발을 하기 위해 reset css가 사용 되는 것이다.
- 그런데 이 reset css는 여러가지이다. 이 중 가장 대표적인 것이 normalize css이다.
- 이는 부트스트랩이 기본 표준으로 정한 것이다. bootstrap-rebot.css라는 파일명으로 normalize css를 자체적으로 커스텀해서 사용하고 있다.
- 웹 표준 기준으로 브라우저 중 하나가 불일치 한다면 차이가 있는 브라우저를 수정하는 방법이다.
## typography
- 제목, 본문 텍스트, 목록 등
- <h1 class="display-1">Display 1</h1> 이때 class가 링크에 들어있어서 자동으로 반영된다. 
- display headings, inline text elements, lists 같은 요소들이 있음
## colors
- 부트스트랩은 색상도 지원한다.
- 텍스트나 보더 백그라운드 및 다양한 요소에 사용하는 부트스트랩의 색상 키워드가 있다.
- text나 background 등 있다.
## Component
- 부투스트랩에서 제공하는 ui관련 요소
- 버튼, 네비게이션 바,카드, 폼, 드롭다운 등
- 일관된 디자인을 제공하여 웹 사이트의 구성 요소를 구축하는데 유용하게 활용하기에 컴포넌트를 쓴다.
## Semantic Web
- html semantic element- 기본적인 모양과 기능 이외에 의미를 가지는 html요소
- html semantic element- 기본적인 모양과 기능 이외에 의미를 가지는 html요소
- 기능적인 것 보다는 의미만 내포한다.
- CSS 방법론
- CSS를 효율적이고 유지보수가 용이하게 작성하기 위한 일련의 가이드라인
- OOCSS- 객체 지향적 접근법을 적용하여 css를 구성하는 방법론
- 구조와 스킨을 분리:  
  - 구조와 스킨을 분리함으로써 재사용 가능성을 높인다.
  - 모든 버튼의 공통 구조를 정의 + 각각의 스킨을 정의
- 컨테이너와 콘텐츠를 분리한다.  
  - 객체에 직접 적용하는 대신 객체를 둘러싸는 컨테이너에 스타일을 적용
  - 스타일을 정의할 때 위치에 의존적인 스타일을 사용하지 않도록 한다
  - 콘텐츠를 다른 컨테이너로 이동시키거나 재배치할 때 스타일이 깨지는 것을 방지