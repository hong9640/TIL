상속- 한 부모 클래스의 속성과 메서드르 다른 자식 클래스가 물려받는 것
필요한 이유-코드 재사용-기존 클래스 수정 안해도 됨., 계층 구조-더 구체적인 클래스 만들 수 있음
ex) 캐릭터 안에 전사 마법사 이렇게 있음. 캐릭터라는 클래스에서 전사, 마법사에 물려줌.
자세히는 클래스 이중구조 임.
class Animal:
    def eat(self):
        print('먹는 중')

class Dog(Animal):
    def bark(self):
        print('멍멍')--> 이런식으로 클래스 안에 클래스가 들어가 있음.
메서드 오버라이딩- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의
다중 상속- 중복된 속성이나 메서드가 있는 경우, 상속 순서에 의해 결정됨.
mro 알고리즘을 사용하여 클래스 목록을 생성, mro- 파이썬이 메서드를 찾는 순서에 대한 규칙, 메서드 결정 순서
class(D(B, C): 이렇게 있으면 속성이 d에서 발견 안되면 b 에서 찾고, 거게에도 없으면 c에서 찾고 이런식으로 지행됨
super()-> 부모 클래스의 메서드를 호출하기 위해 사용하는 내장 함수
다중 상속 상황에서 특히 유용
-1. 단일 상속 구조
명시적으로 이름을 지정하지 않고 부모 클래스 참조 가능, 더 유지관리 쉽게 만들 수 있음
코드 수정이 더 적게 필요
-2. 다중 상속 구조
그런데 좀 혼란해 질 수 있는데 이렇게 되는 것을 막는 것이 개발자가 해야 할 일!
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 부모 클래스의 __init__ 호출
        self.breed = breed
이게 super 함수를 사용한 상속
class Dog(Animal):
    def speak(self):  # 부모 클래스의 speak()을 오버라이드
        print(f"{self.name} barks")
이게 오버리이딩. 메서드를 새로 덮어씀.
class Animal:
    def speak(self):
        print("Animal makes a sound")

class Mammal:
    def walk(self):
        print("Mammal can walk")

class Dog(Animal, Mammal):  # Animal과 Mammal 클래스를 상속받음
    def speak(self):
        print("Dog barks")

# 사용 예시
dog = Dog()
dog.speak()  # 출력: Dog barks
dog.walk()   # 출력: Mammal can walk
이게 다중 상속. mro는 무조건 순서대로!
super는 명시적으로 특정 부모 클래스를 가리키지 않고도 올바른 순서로 부모 초기화나 메서드 호출이 가능
mro는 무조건 순서대로이다. 호출 순서가 예측 가능하게 유지, 재사용성과 유지보수성 향상

버그- 소프트웨어에서 발생하는 오류 또는 결함. 프로그램의 예상된 동작과 실제 동작 사이의 불일치
디버깅- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정, 프로그램의 오작동 원인을 식별하여 수정하는 작업
-print하는게 가장 일반적인 방법, 파이썬 튜터를 활용하거나 눈으로 디버깅 하거나 ㅋㅋㅋㅋ
디버깅은 결국 에러를 해결하는 방법
에러-프로그램 실행 중에 발생하는 예외 상황
2개가 있음 문법에러, 예외, 
문법에러에서는 오타, 괄호 누락 등 문법적 오류
예외- 프로그램 실행 중에 감지되는 에러
내장 예외- 예외 상황을 나타내는 예외 클래스들
이런 예외는 파이썬 홈페이지 들어가면 있음. 파이썬 내장예외 찍으면 나올 거임.
예외 처리- 예외가 발생했을 때 프로그램이 적절하게 처리할 수 있도록 하는 방법
try- 예외가 발생할 수 있는 코드 작성
except- 예외가 발생했을 때 실행할 코드 작성
else-예외가 발생하지 않았을 때 실행할 코드 작성
finally- 예외 발생 여부와 상관없이 항상 실행할 코드 작성
try-except 구조- 예외가 발생하면 프로그램 흐름은 try 블록을 빠져나와 해당 예외에 대응하는 except블록으로 이동
else- finally
그렇게 많지는 않은데 추가 작업을 진행하고 finally블록은 예외 발생여부와 상관없이 항상 실행할 코드를 작성
try-except를 쓸 때는 가장 구체적이 예외부터 작성해야지 안그러면 제대로 작동 안됨
as 키워드- 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
그리고 try문은 if-else와 같이 쓸 수 있음!
EAFP - 예외처리를 중심으로 코드를 작성하는 접근 방식 try문-일단 씀! 그리고 틀리면 예외 출력
LBYL- 값 검사를 중심으로 코드를 작성하는 접근방식 if-else문- 실행하기 전에 조건을 검사