## Tree
- 비선형 구조이다.
- 원소들 간에 1:n 관계를 가지는 자료 구조
- 원소들 간에 계층관계를 가지는 계층형 자료구조
- 사이클이 없는 무향연결 그래프의 특별한 형태이다.
- 한 개 이상의 노드로 이루어진 유한 집합이다.
- 노드 중 최상위 노드를 root라 한다.
- 나머지 노드들은 subtree라 한다.
- 노드 - 트리의 원소
- 간선- 노드를 연결하는 선
- 루트 노드 - 트리의 시작 노드
- 형제노드 - 같은 부모 노드의 자식 노드들
- 조상노드 - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브트리 - 서브트리에 있는 하위 레벨의 노드들
- 차수(degree):  
  - 노드의 차수: 노드에 연결된 자식 노드의 수
  - 트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
  - 단말노드 : 차수가 0인 노드, 자식 노드가 없는 노드
- 높이:  
  - 노드의 높이: 루트에서 노드에 이르는 간선의 수. 노드의 레벨
  - 트리의 높이: 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨
### 이진트리:  
  - 모든 노드들이 2개의 서브 트리를 갖는 특별한 형태의 트리
  - 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리  
    - 왼쪽 자식 노드, 오른쪽 자식 노드
    - 레벨 i에서 노드의 최대 개수는 2^i개, 높이가 h인 이진 트리가 가질 수 업슨ㄴ 노드의 최소 갯수는 (h + 1)개가 되며 최소 갯수sms 2^(h+1)-1 개가 된다.
- 포화 이진 트리  
  - 모든 레벨에 토드가 포화상태로 차 있는 이진 트리
  - 높이가 h일 때, 최대 노드의 개수인 (2^(h+1)-1)의 노드를 가진 이진 트리
- 완전 이진 트리  
  - 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번 까지 빈 자리가 없는 이진 트리
- 편향 이진 트리  
  - 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진트리  
    - 왼쪽 편향 이진 트리
    - 오른쪽 편향 이진 트리
### 순회  
- 트리의 각 노드를 중복되지 않게 전부 방분하는 것을 말하는데 트리는 비선형 구조이기 
  때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없다.
- 순회: 트리의 노드들을 체계적으로 방문하는 것  
  - 전위순회: VLR, 부모 노드 방문 후, 자식 노드를 좌, 우 순서로 방문한다.
  - 중위순회: LVR, 왼쪽 자식노드, 부모노드, 오른쪽, 자식 노드 순으로 방문한다.
  - 후위순회: LRV, 자식노드를 좌우 순서로 방문한 후, 부모 노드로 방문한다.
- 전위순회  
  - 현재 노드 n을 방문하여 처리한다. ->V
  - 현재 노드 n의 왼쪽 서브트리로 이동한다 ->L
  - 현재 노드 n의 오른쪽 서브트리로 이동한다. -> R
  - 제일 깊은 노드를 먼저 방문한 후 다른 로드를 방문한다.
- 중위순회  
  - 현재 노드 n의 왼쪽 서브트리로 이동한다 ->L
  - 현재 노드 n을 방문하여 처리한다. ->V
  - 현재 노드 n의 오른쪽 서브트리로 이동한다. -> R
- 후위순회  
  - 현재 노드 n의 왼쪽 서브트리로 이동한다 ->L
  - 현재 노드 n의 오른쪽 서브트리로 이동한다. -> R
  - 현재 노드 n을 방문하여 처리한다. ->V
### 배열을 이용한 이진 트리의 표현
- 맨 처음 노드부터 레벨0->레벨1, 2, 3이렇게 내려간다.
- 노드 번호의 성질  
  - 노드 번호가 i인 노드의 부모 노드 번호 = i/2
  - 노드 번호가 i인 노드의 왼쪽 자식 노드 번호 = 2*i
  - 노드 번호가 i인 노드의 오른쪽 자식 노드 번호 = 2*i + 1
  - 레벨n의 노드 번호 시작 번호 = 2^n
### 이진 트리의 저장
- 부모 번호를 인덱스로 자식 번호를 저장
### 수식트리
- 수식을 표현하는 이진 트리
- 수식 이진트리라고 부르기도 한다
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 잎 노드

### 이진탐색트리
- 탐색작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 갖는다.
- 왼쪽->루트->오른쪽
- 왼족 서브트리와 오른쪽 서크트리도 이진탐색트리다
- 중위순회하며 오름차순으로 정렬된 값을 얻을 수 있다.
- 연산은 2가지  
  - 탐색 연산  
    - 루트에서 시작.
    - 탐색할 키 값x를 루트 노드의 기 값과 비교
    - 키 값이 루트노드의 키 값보다 작으면 왼쪽으로
    - 키 값이 루트노드의 키 값보다 크면 오른쪽으로
    - 같으면 탐색 성공
    - 서브트리에 대해서 순환적으로 탐색 연산 반복
  - 삽입연산  
    - 먼저 탐색 연산 수행
    - 탐색 실패한 위치에 원소 삽입
- 탐색, 삽입, 삭제 시간은 트리의 높이 만큼 걸린다.
- 평균의 경우- 이진트리가 균형적으로 생성되어 있는 경우
- 최악의 경우- 한쪽으로 치우친 경사 이진트리의 경우
### 힙
- 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 최대 힙  
  - 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - 루트노드: 키 값이 가장 큰 노드
  - 부모 노드의 키가 자식 노드의 키보다 크다.
- 최소 힙  
  - 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - 루트노드: 키 값이 가장 작은 노드
  - 부모노드의 키가 나식 노드의 키보다 작다.
- 힙의 삽입은 트리의 가장 마지막 위치에 노드를 삽입하는 것이다.
- 부모와 비교해 힙 성질이 깨지면 위로 올리기
- 삭제의 경우 루트 노드(최소,최댓값)만 삭제 가능
- 마지막 노드를 루트로 옮긴 후, 자식과 비교해 힙 성질이 지켜지도록 내려보내기
- 우선순위 큐 구현에 힙을 사용
## SW 문제해결
- 복잡도
- Big-Oh-> 최악의 경우
- Big -Omega -> 최선의 경우
- Bog-Theta -> 평균적인 경우
- O(logN)은 O(1)보다는 느리지만, 유사한 성능을 보인다고 결론을 낼 수 있다.
### 진수
- 진법: 수를 표현하기 위한 기수법  
  - 10진법: 일상적으로 사용하는 숫자 체계
  - 2진법: 컴퓨터 내부에서 사용하는 진법(1, 0)
  - 8진법: 0-7까지의 숫자를 사용하는 진법
  - 16진법: 0-9 + A = 10,B = 11,C = 12,D = 13,E = 14,F = 15 총 16가지 기호
  - 16진수를 사용하는 이유는 10진수는 인간이 이해하기 편하지만 연산이 오래 걸리고 2진수는 인긴이 이해하기 어렵지만 연산 속도가 빠르기에 16진수를 쓴다.
- ex) 10진수 `10`은 2진수로 `1010`, 16진수로 `A`
- 10진수 `255`는 16진수로 `FF`, 2진수로 `11111111`
- 컴퓨터 내부는 2진수로 연산을 수행하고 사람이 인식하기 쉬워야 하기 때문에 진법 변환이 필요하다
- 진법변환방법  
  - 10진수 -> 2진수:  
    - 정수를 2로 나눈 나머지를 거꾸로 읽으면 2진수이다.
    - 1. 13 ÷ 2 = 6 … 나머지 1  
    - 2. 6 ÷ 2 = 3 … 나머지 0  
    - 3. 3 ÷ 2 = 1 … 나머지 1  
    - 4. 1 ÷ 2 = 0 … 나머지 1 (종료)  
    - 뒤에서부터 나머지: `1101`
- 10진수 -> 16진수:  
  - 10진수를 16으로 나눈 나머지를 거꾸로 한다.
  - 10진수 255 -> 16진수 `FF`
- 10진수 -> 8진수
  - 10진수를 8로 나눈 나머지를 거꾸로 한다.
  - 10진수 32-> 8진수 40
- 2진수 -> 10지수  
  - 2진수의 각 자리수를 2의 거듭제곱으로 해석한다.
  - 2진수 `1011` →
  - `(1 × $2^3$) + (0 × $2^2$) + (1 × $2^1$) + (1 × $2^0$)`
  - = 8+0+2+1 = 11(10진수)
- 16진수 -> 2진수:  
  - 16진수 A(10진수 10)2진수 1010
  - 16진수를 10진수로 바꾸고 2진수로 변환
- **진수 기억하기!** 2진수 -> 0b, 8진수 -> 0o, 16진수 -> 0x
- format 함수를 사용하여 변환 가능하다.
- format(decimal_num, '04b') 이렇게 하거나
- "{:X}".format(decimal) 이렇게 하거나
- 내장함수 사용한 진법 변환
- num1 = int("1011", 2)   # "1011"(2진수) → 10진수 11  
  num2 = int("FF", 16)    # "FF"(16진수) → 10진수 255  
  num3 = int("27", 8)     # "27"(8진수) → 10진수 23  
  이런식으로 int를 사용하여 변환 가능
- format(13, 'b')   # "1101"  
  format(13, 'x')   # "d"  
  format(13, 'X')   # "D"
  이때 X는 16진수, o는 8진수
- bin(13)  # "0b1101"  
  - 10진수를 이진 문자열로 변환
### bin(), oct(), hex()  
  print(bin(13))  # 0b1101  
  print(oct(13))  # 0o15  
  print(hex(13))  # 0xd
### `format()`에서 너비/정렬 지정

`format()` 함수를 사용할 때, **`'<width><type>'`** 형식으로 **출력 너비**를 지정할 수도 있음

- **`'4b'`**: 2진수 형태로 출력하되, **최소 4자리** 너비를 확보하고 **오른쪽 정렬** (기본 정렬)
- **`'08b'`**: 2진수 형태로 출력, **최소 8자리** 너비 확보 + **왼쪽을 '0'으로 채움**
- **`'4x'`**: 16진수 형태로 4자리 너비 + 오른쪽 정렬
- num = 5  
  
  print(format(num, 'b'))       # '101'            (기본)  
  print(format(num, '4b'))      # ' 101'           (최소 4자리, 오른쪽 정렬)  
  print(format(num, '08b'))     # '00000101'       (8자리, 앞을 '0'으로 채움)  
  print(format(num, '>8b'))     # '     101'       (8자리, 오른쪽 정렬, 공백 채움)  
  print(format(num, '<8b'))     # '101     '       (8자리, 왼쪽 정렬)  
  print(format(num, '^8b'))     # '   101   '      (8자리, 가운데 정렬)  

### 부분집합
- 집합에 포함된 원소들을 선택
- 나올 수 있는 모든 조합을 구한다.
- 이를 완전탐색의 하나의 방법이다.
- 만약 a = [1,2,3,4]가 있으면 이 리스트의 모든 부분집합은 공집합 포함해서 2^4이다.
- 바이너리 카운팅이 있는데 n번 비트값이 1이면 n번 원소가 포함되었음을 의미한다.
### 비트연산
- 컴퓨터에서 데이터는 0과 1로 이루어진 비트로 표현된다.
- 1bit는 0과 1을 표현하는 정보의 단위
- 1byte는 8bit를 묶어 1byte라고 한다.
- 비트연산을 하면 매우 빠르고 효율적으로 동작이 가능하다.
- 비트연산은 10진수를 0,1의 비트 단위로 변경하여 이를 서로 비교하는 연산 이라고 생각하면 된다.
- 연산자:  
  - & : 비트단위로 and연산을 한다.
  - | : 비트 단위로 or 연산을 한다.
  - ^ : 비트 단위로 xor연산을 한다. (같으면 0, 다르면 1)
  - ~ : 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.
  - << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
  - 왼쪽 갈 때가 없으면 오른쪽에 0 추가가
  - '>>' : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
  - 오른쪽으로 갈 때가 없으면 비트삭제
  - 연산자 순위: ~, 이동연산자, &, ^, |
  - 응용:  
    - 1 << n: 2^n 즉, 2의 n제곱의 값을 가지며, 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다.
    - i &(1 << n): i의 n번째 비트가 1인지 아닌지를 확인할 수 있다.  
    - i = 5 (이진수: 0b101)  
    - idx = 1일 때, (1 << 1)은 0b10입니다.  
    - i & (1 << 1)이 0b101 & 0b010 = 0b000이면 i의 1번째 비트는 0이므로 False입니다.  
    - idx = 0일 때, (1 << 0)은 0b001입니다.  
    - i & (1 << 0)이 0b101 & 0b001 = 0b001이면 i의 0번째 비트는 1이므로 True입니다.  
    - 결괏값이 0보다 크면 n번째 비트는 1임이 확정된다.  
- bin -> 10진수 2진수로 변환
- 음수 표현 방법
- 컴퓨터는 음수를 2의 보수로 관리한다.
- 맨 앞자리 bit는 음수 or 양수를 구분하는 비트이다
- 부호 비트만 사용
- 1의 보수
- 간단하게 2진수의 값을 0->1, 1->0 했을 때 동일하면 음수라고 생각하면 된다.
- 2의 보수 -> 10001을 모두 뒤집고 +1한다.
- 01110 + 1 -> 01111
- 1111000 -> 0000111 + 1 -> 0001000
- 실수 출력 방법 : f-string 문법을 지향한다. 또는 소숫점 둘째 자리에서 반올림한다.
- ex)  {t2:.2f}
- 컴퓨터는 실수를 내부적으로 근사적으로 관리한다.
- print(0.1 + 0.1 + 0.1) == False 인데 그 이유는 실수는 근사 값으로 저장되며 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져오기 때문이다.
- 그리고 실수는 2를 곱한 후 정수를 차례대로 출력하여 2진수로 변환해야 한다.
- **전체정리**  
  - 1. 비트연산 연산자 배움
  - 2. 실수  
    - 컴퓨터의 실수 저장 및 활용 방법
    - 근사치로 인한 오차, 반올림, 버림 등은 문제 잘 읽고 주의해야 한다.
### 완전검색
- 문제 푸는 방법.  
  - 1. 문제를 잘 읽어야 한다.
  - 2-1. 단순반복문+ 조건문으로 구현이 가능한가?
  - 2-2. 재귀호출로 모든 경우를 본다면? 
  - 그런데 이 과정까지는 시간, 공간이 부족하다.
  - 3. 규칙성을 찾아야 한다.  
    - 문제마다 숨겨진 규칙이나 패턴
    - 순간마다 최선의 선택이 정답이다.(greedy)
  - 4. 재계산을 하지 말자.  
    - 중복되는 문제의 결과를 저장해놓고 재활용하자(dp)
  - 5. 그래프(트리) 전체 노드를 탐색하자! dfs나 bfs
  - 6. 그런데 N이 너무 크면 새로운 알고리즘이나 자료 구조를 고민해야 한다.
  - 7. 알고리즘은 재귀 호출 접근법의 경우 백트래킹, 최소값/구간, 최대값/구간 등은 정렬하자
  - 8. 심화 문제들:  
    - 최단거리: dijkstra, 최소비용: MST
  - 9. 자료구조는 한 번 만들어 놓고 여러번 조회한다.
- 재귀호출에서는 return의 역할을 잘 알아야 한다.
- 중복순열 - 서로 다른 N개에서 R개를 중복을 허용하고 순서를 고려하여 나열하는 것
### 완전 탐색
- 부르트 포스- 모든 가능한 경우를 모두 시도해 정답을 찾아내는 알고리즘
**순열 조합 차이점**
- 순열은 순서가 중요, 조합은 순서가 중요하지 않다.
- 예를 들어 1,2,3에서 2개를 선택한다고 할 때 순열은 12,13, 21, 23, 31, 32 이렇게 6개가 나온다.
- 조합은 12, 13, 23 이렇게 3개가 된다.
### 그리디로 풀 수 있는 조건
- 1. 탐욕적 선택 조건  
  - 각 단계에서 최적해 선택이 이후 단계선택에 영향을 주지 않는다.
  - 즉, 각 단계 규칙이 변하면 안된다.
- 2. 최적 부분 구조  
  - 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이어야 한다.
- 3. 반례가 없는지 확인해야 한다.
### 순열 팁
- used 쓰고 if문으로 중복 되는 것을 빼야 순열이다.
- 
### DP 접근법
- top-down 방식  
  - dp(메모이제이션)
  - 거듭제곰 문제
- bottom-up 방식  
  - 시작점을 정해둔다.
  - 앞으로 쌓아나아가면서 진행
  - 기존값을 활용
  - 가장 좋은 값을 계산해서 저장하면서 진행
  - 점화식을 구하는 경우가 많다.
### 분할 정복
- 문제를 분할해서 해결한다.
- 대표적으로 퀵, 병합, 이진검색에 대해 학습
- 분할: 해결할 문제를 여러 개의 작은 부분으로 나눈다.
- 정복: 나눈 작은 문제를 각각 해결한다.
- 통합: 해결된 해답을 모든다.
- 분할정복 예시: 거듭제곱  
  - O(logn)의 시간 복잡도를 가진다.
- 병합정렬:  
  - O(nlogn)의 시간 복잡도를 가지며 top-down 방식을 가진다.
  - 전체 자료 집합에 대하여 최소 크기의 부분집합이 될 때까지 분할 작업을 계속한다.
  - 2개의 부분집합을 정렬하면서 하나의 집합으로 병합 -> 병합단계
  - 8개의 부분집합이 1개로 병합될 때까지 반복함.
### 퀵 정렬
- 분할할 때 기준 아이템 중심으로 분할한다.
- 기준보다 작은 것은 왼편, 큰 것은 오른편에 위치시킨다.
- 각 부분 정렬이 끝난 후, 병합 정렬은 병합 이란 후처리 작업이 필요하나, 퀵 정렬은 필요로 하지 않는다.
- 평균적으로는 O(nlogn)속도라는 빠른 속도로 정렬이 되나 최악의 경우 O(n**2)까지 갈 수 있다.
- 작업 영역을 정한다 -> 작업영역 중 가장 왼쪽에 있는 수를 pivot이라고 하자.
- -> pivot을 기준으로 왼쪽에는 Pivot보다 작은 수를 배치한다.(정렬안됨) 오른쪽에는 pivot보다 큰 수를 배치시키다.(정렬 안됨)
- 파티셔닝이 끝나고 pivot의 위치는 확정된다. 즉, 정렬이 다 되었을 때에도 pivot의 위치는 지금 위치 그대로 배정된다.
- 피봇의 경우 왼쪽 끝/ 오른쪽 끝/ 임의의 세개 값 중에 중간 값을 선택한다.
### lomuto partition 알고리즘
- 더 느리다. 하지만 구현이 더 쉽다.
- 최악의 경우는 언제일까?  
  - 역순 정렬이 되어있을 때 최악의 성능 or 피벗 설정 잘못되었을 때 O(N^2)
  - 포어 파티션-> 피벗 기준, i,j를 좌우 끝에서부터 가운데로 이동
  - 로무토 파이션: 피벗을 제일 우측, i,j를 왼쪽에서 같이 이동
  - 퀵 정렬:  
    - 평균적인 속도가 o(NlogN)으로 빠르다. 특히 대규모의 데이터일 때 효과적으로 동작한다.
### 백트래킹
- 경우의 수를 줄여주는데 모든 경우를 찾는 것이 아닌 내가 원하지 않는 선택지가 나오지 않으면 부모로 되돌아 가는 것을 마한다.
- 유망하지 않은 경우의 수는 보지 말자!
- 먼저 완전탐색하고 가지치기 하자.
- 여기서 재귀, dfs, 백트래킹은 가족이다. 한 세트로 가져온다.
- ### 이진트리
- 높이가 h인 이진 트리가 가질 수 있는 노드의 최소 개수: (h + 1)
- 최대 개수( 2^h+1 -1)
- 레벨 i에서 노드의 최대 개수: 2^i
- 포화 이진 트리의 경우 최대 노드 개수: (2^h+1 -1)의 노드를 가진 이진 트리
- 저장법법: 그래프와 똑같이 인접리스트, 일차원 배열-> 인덱스: 부모노드, 왼쪽자식: idx * 2, 오른쪽: idx * 2 + 1

### 이진탐색트리
- 탐색 작업을 효율적으로 하기 위한 자료 구조로 모든 원소는 서로 다른 유일한 키를 갖는다.
- 루트에서 탐색 시작하고 x==k면 탐색 성고, x '<' k 는 왼쪽 서브트리 연산 수행, x '>' k는 오른쪽 서브 트리에 대해서 연산 수행
- 서브 트리에 대해서 순환적으로 탐색 연산을 반복하고 수행할 서브트리가 없으면 탐색 실패
- 삽입 연산의 경우 먼저 탐색 연산을 수행하고 탐색 실패한 위치에 원소를 삽입한다.
- 삭제 연산의 경우 1. 삭제할 노드를 먼저 찾고, 2. 리프노드라면 그냥 지움. 3. 리프노드가 아니라면 자식이 하나라면 부모와 자식을 연결 4. 자식이 2라면 트리를 반으로 나눠서 왼쪽 서브트리의 가장 큰 값을 가져오거나 오른쪽 서브트리의 가장 작은 값을 넣거나.
### 힙 트리
- heapq 라이브러리 사용하는 법 알아야 함
- 최대힙, 최소힙은 부모가 자식보다 무조건 크거나 작은 것임
- 그리고 힘은 무조건 완전 이진 트리이다.
- 무조건 logn의 시간 복잡도를 갖는다.
- 그리고 힙을 삭제하는 경우 루트의 원소를 삭제하고 마지막 노드를 삭제 후 그 값을 루트 노드에 넣고 자리바꾸기를 하면 된다.
- 힙 사용 예는 규의 구현과 정렬이다.
### 그래프
- 정점의 최대 간선의 수는 V*(V - 1)/2 이다.
- 무향그래프 - 방향성이 없다
- 유향그래프-> 방향성이 존재한다.
- 0-2-4-6 같이 경로 중 한 정점을 최대한 한번만 지나는 경로를 단순경로라고 한다.
- 시작한 정점에서 끝나는 경로를 사이클 이라고 한다.
- 인접 행렬은 두 정점을 연결하는 간서의 유무를 행렬로 표현한 것이다.
- 인접행렬의 단점은 메모리 낭비가 너무 큰 것이다.
- 그래서 인접 리스트로 하는 것이 메모리 낭비가 더 낮다.
- 하지만 인접 리스튿 단점이 있는데 예를 들어 정점 추가, 삭제에서 append연산에서 시간이 조금 오래 걸릴 수 있다.
- 알고리즘의 기본은 완전탐색이다. 
- dfs나 bfs는 비선형구조인 그래프의 자료를 모두 탐색 하는 것이다.

### 서로소 집합
- 교집합이 없다.
- 집합에 속한 하나으 특정 멤버를 통해 각 집합들을 구분하는데 이른 대표자 라고 한다.
- 상호베타 집합을 표현하는 방법:  
  - 연결리스트
  - 트리
- 상호배타 집합 연산:  
  - Make-Set(x) : 자기 자신을 대표자로 설정, x개의 집합을 생성
  - Find-Set(x) : 대표자가 누구냐, return c 이렇게 하면 c로 대표자를 바꿔라 라는 뜻
  - Union(x, y) : x, y를 하나의 집합으로 묶자