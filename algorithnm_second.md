## Tree
- 비선형 구조이다.
- 원소들 간에 1:n 관계를 가지는 자료 구조
- 원소들 간에 계층관계를 가지는 계층형 자료구조
- 사이클이 없는 무향연결 그래프의 특별한 형태이다.
- 한 개 이상의 노드로 이루어진 유한 집합이다.
- 노드 중 최상위 노드를 root라 한다.
- 나머지 노드들은 subtree라 한다.
- 노드 - 트리의 원소
- 간선- 노드를 연결하는 선
- 루트 노드 - 트리의 시작 노드
- 형제노드 - 같은 부모 노드의 자식 노드들
- 조상노드 - 간선을 따라 루트 노드까지 이르는 경로에 있는 모든 노드들
- 서브트리 - 서브트리에 있는 하위 레벨의 노드들
- 차수(degree):  
  - 노드의 차수: 노드에 연결된 자식 노드의 수
  - 트리의 차수: 트리에 있는 노드의 차수 중에서 가장 큰 값
  - 단말노드 : 차수가 0인 노드, 자식 노드가 없는 노드
- 높이:  
  - 노드의 높이: 루트에서 노드에 이르는 간선의 수. 노드의 레벨
  - 트리의 높이: 트리에 있는 노드의 높이 중에서 가장 큰 값, 최대 레벨
### 이진트리:  
  - 모든 노드들이 2개의 서브 트리를 갖는 특별한 형태의 트리
  - 각 노드가 자식 노드를 최대한 2개 까지만 가질 수 있는 트리  
    - 왼쪽 자식 노드, 오른쪽 자식 노드
    - 레벨 i에서 노드의 최대 개수는 2^i개, 높이가 h인 이진 트리가 가질 수 업슨ㄴ 노드의 최소 갯수는 (h + 1)개가 되며 최소 갯수sms 2^(h+1)-1 개가 된다.
- 포화 이진 트리  
  - 모든 레벨에 토드가 포화상태로 차 있는 이진 트리
  - 높이가 h일 때, 최대 노드의 개수인 (2^(h+1)-1)의 노드를 가진 이진 트리
- 완전 이진 트리  
  - 높이가 h이고 노드 수가 n개일 때, 포화 이진 트리의 노드 번호 1번부터 n번 까지 빈 자리가 없는 이진 트리
- 편향 이진 트리  
  - 높이 h에 대한 최소 개수의 노드를 가지면서 한쪽 방향의 자식 노드만을 가진 이진트리  
    - 왼쪽 편향 이진 트리
    - 오른쪽 편향 이진 트리
### 순회  
- 트리의 각 노드를 중복되지 않게 전부 방분하는 것을 말하는데 트리는 비선형 구조이기 
  때문에 선형 구조에서와 같이 선후 연결 관계를 알 수 없다.
- 순회: 트리의 노드들을 체계적으로 방문하는 것  
  - 전위순회: VLR, 부모 노드 방문 후, 자식 노드를 좌, 우 순서로 방문한다.
  - 중위순회: LVR, 왼쪽 자식노드, 부모노드, 오른쪽, 자식 노드 순으로 방문한다.
  - 후위순회: LRV, 자식노드를 좌우 순서로 방문한 후, 부모 노드로 방문한다.
- 전위순회  
  - 현재 노드 n을 방문하여 처리한다. ->V
  - 현재 노드 n의 왼쪽 서브트리로 이동한다 ->L
  - 현재 노드 n의 오른쪽 서브트리로 이동한다. -> R
  - 제일 깊은 노드를 먼저 방문한 후 다른 로드를 방문한다.
- 중위순회  
  - 현재 노드 n의 왼쪽 서브트리로 이동한다 ->L
  - 현재 노드 n을 방문하여 처리한다. ->V
  - 현재 노드 n의 오른쪽 서브트리로 이동한다. -> R
- 후위순회  
  - 현재 노드 n의 왼쪽 서브트리로 이동한다 ->L
  - 현재 노드 n의 오른쪽 서브트리로 이동한다. -> R
  - 현재 노드 n을 방문하여 처리한다. ->V
### 배열을 이용한 이진 트리의 표현
- 맨 처음 노드부터 레벨0->레벨1, 2, 3이렇게 내려간다.
- 노드 번호의 성질  
  - 노드 번호가 i인 노드의 부모 노드 번호 = i/2
  - 노드 번호가 i인 노드의 왼쪽 자식 노드 번호 = 2*i
  - 노드 번호가 i인 노드의 오른쪽 자식 노드 번호 = 2*i + 1
  - 레벨n의 노드 번호 시작 번호 = 2^n
### 이진 트리의 저장
- 부모 번호를 인덱스로 자식 번호를 저장
### 수식트리
- 수식을 표현하는 이진 트리
- 수식 이진트리라고 부르기도 한다
- 연산자는 루트 노드이거나 가지 노드
- 피연산자는 모두 잎 노드

### 이진탐색트리
- 탐색작업을 효율적으로 하기 위한 자료구조
- 모든 원소는 서로 다른 유일한 키를 갖는다.
- 왼쪽->루트->오른쪽
- 왼족 서브트리와 오른쪽 서크트리도 이진탐색트리다
- 중위순회하며 오름차순으로 정렬된 값을 얻을 수 있다.
- 연산은 2가지  
  - 탐색 연산  
    - 루트에서 시작.
    - 탐색할 키 값x를 루트 노드의 기 값과 비교
    - 키 값이 루트노드의 키 값보다 작으면 왼쪽으로
    - 키 값이 루트노드의 키 값보다 크면 오른쪽으로
    - 같으면 탐색 성공
    - 서브트리에 대해서 순환적으로 탐색 연산 반복
  - 삽입연산  
    - 먼저 탐색 연산 수행
    - 탐색 실패한 위치에 원소 삽입
- 탐색, 삽입, 삭제 시간은 트리의 높이 만큼 걸린다.
- 평균의 경우- 이진트리가 균형적으로 생성되어 있는 경우
- 최악의 경우- 한쪽으로 치우친 경사 이진트리의 경우
### 힙
- 완전 이진 트리에 있는 노드 중에서 키값이 가장 큰 노드나 키값이 가장 작은 노드를 찾기 위해서 만든 자료구조
- 최대 힙  
  - 키값이 가장 큰 노드를 찾기 위한 완전 이진 트리
  - 루트노드: 키 값이 가장 큰 노드
  - 부모 노드의 키가 자식 노드의 키보다 크다.
- 최소 힙  
  - 키값이 가장 작은 노드를 찾기 위한 완전 이진 트리
  - 루트노드: 키 값이 가장 작은 노드
  - 부모노드의 키가 나식 노드의 키보다 작다.
- 힙의 삽입은 트리의 가장 마지막 위치에 노드를 삽입하는 것이다.
- 부모와 비교해 힙 성질이 깨지면 위로 올리기
- 삭제의 경우 루트 노드(최소,최댓값)만 삭제 가능
- 마지막 노드를 루트로 옮긴 후, 자식과 비교해 힙 성질이 지켜지도록 내려보내기
- 우선순위 큐 구현에 힙을 사용
## SW 문제해결
- 복잡도
- Big-Oh-> 최악의 경우
- Big -Omega -> 최선의 경우
- Bog-Theta -> 평균적인 경우
- O(logN)은 O(1)보다는 느리지만, 유사한 성능을 보인다고 결론을 낼 수 있다.
### 진수
- 진법: 수를 표현하기 위한 기수법  
  - 10진법: 일상적으로 사용하는 숫자 체계
  - 2진법: 컴퓨터 내부에서 사용하는 진법(1, 0)
  - 8진법: 0-7까지의 숫자를 사용하는 진법
  - 16진법: 0-9 + A = 10,B = 11,C = 12,D = 13,E = 14,F = 15 총 16가지 기호
  - 16진수를 사용하는 이유는 10진수는 인간이 이해하기 편하지만 연산이 오래 걸리고 2진수는 인긴이 이해하기 어렵지만 연산 속도가 빠르기에 16진수를 쓴다.
- ex) 10진수 `10`은 2진수로 `1010`, 16진수로 `A`
- 10진수 `255`는 16진수로 `FF`, 2진수로 `11111111`
- 컴퓨터 내부는 2진수로 연산을 수행하고 사람이 인식하기 쉬워야 하기 때문에 진법 변환이 필요하다
- 진법변환방법  
  - 10진수 -> 2진수:  
    - 정수를 2로 나눈 나머지를 거꾸로 읽으면 2진수이다.
    - 1. 13 ÷ 2 = 6 … 나머지 1  
    - 2. 6 ÷ 2 = 3 … 나머지 0  
    - 3. 3 ÷ 2 = 1 … 나머지 1  
    - 4. 1 ÷ 2 = 0 … 나머지 1 (종료)  
    - 뒤에서부터 나머지: `1101`
- 10진수 -> 16진수:  
  - 10진수를 16으로 나눈 나머지를 거꾸로 한다.
  - 10진수 255 -> 16진수 `FF`
- 10진수 -> 8진수
  - 10진수를 8로 나눈 나머지를 거꾸로 한다.
  - 10진수 32-> 8진수 40
- 2진수 -> 10지수  
  - 2진수의 각 자리수를 2의 거듭제곱으로 해석한다.
  - 2진수 `1011` →
  - `(1 × $2^3$) + (0 × $2^2$) + (1 × $2^1$) + (1 × $2^0$)`
  - = 8+0+2+1 = 11(10진수)
- 16진수 -> 2진수:  
  - 16진수 A(10진수 10)2진수 1010
  - 16진수를 10진수로 바꾸고 2진수로 변환
- **진수 기억하기!** 2진수 -> 0b, 8진수 -> 0o, 16진수 -> 0x
- format 함수를 사용하여 변환 가능하다.
- format(decimal_num, '04b') 이렇게 하거나
- "{:X}".format(decimal) 이렇게 하거나
- 내장함수 사용한 진법 변환
- num1 = int("1011", 2)   # "1011"(2진수) → 10진수 11  
  num2 = int("FF", 16)    # "FF"(16진수) → 10진수 255  
  num3 = int("27", 8)     # "27"(8진수) → 10진수 23  
  이런식으로 int를 사용하여 변환 가능
- format(13, 'b')   # "1101"  
  format(13, 'x')   # "d"  
  format(13, 'X')   # "D"
  이때 X는 16진수, o는 8진수
- bin(13)  # "0b1101"  
  - 10진수를 이진 문자열로 변환
- # bin(), oct(), hex()  
  print(bin(13))  # 0b1101  
  print(oct(13))  # 0o15  
  print(hex(13))  # 0xd
### `format()`에서 너비/정렬 지정

`format()` 함수를 사용할 때, **`'<width><type>'`** 형식으로 **출력 너비**를 지정할 수도 있음

- **`'4b'`**: 2진수 형태로 출력하되, **최소 4자리** 너비를 확보하고 **오른쪽 정렬** (기본 정렬)
- **`'08b'`**: 2진수 형태로 출력, **최소 8자리** 너비 확보 + **왼쪽을 '0'으로 채움**
- **`'4x'`**: 16진수 형태로 4자리 너비 + 오른쪽 정렬
- num = 5  
  
  print(format(num, 'b'))       # '101'            (기본)  
  print(format(num, '4b'))      # ' 101'           (최소 4자리, 오른쪽 정렬)  
  print(format(num, '08b'))     # '00000101'       (8자리, 앞을 '0'으로 채움)  
  print(format(num, '>8b'))     # '     101'       (8자리, 오른쪽 정렬, 공백 채움)  
  print(format(num, '<8b'))     # '101     '       (8자리, 왼쪽 정렬)  
  print(format(num, '^8b'))     # '   101   '      (8자리, 가운데 정렬)  

### 부분집합
- 집합에 포함된 원소들을 선택
- 나올 수 있는 모든 조합을 구한다.
- 이를 완전탐색의 하나의 방법이다.
- 만약 a = [1,2,3,4]가 있으면 이 리스트의 모든 부분집합은 공집합 포함해서 2^4이다.
- 바이너리 카운팅이 있는데 n번 비트값이 1이면 n번 원소가 포함되었음을 의미한다.
### 비트연산
- 컴퓨터에서 데이터는 0과 1로 이루어진 비트로 표현된다.
- 1bit는 0과 1을 표현하는 정보의 단위
- 1byte는 8bit를 묶어 1byte라고 한다.
- 비트연산을 하면 매우 빠르고 효율적으로 동작이 가능하다.
- 비트연산은 10진수를 0,1의 비트 단위로 변경하여 이를 서로 비교하는 연산 이라고 생각하면 된다.
- 연산자:  
  - & : 비트단위로 and연산을 한다.
  - | : 비트 단위로 or 연산을 한다.
  - ^ : 비트 단위로 xor연산을 한다. (같으면 0, 다르면 1)
  - ~ : 단항 연산자로서 피연산자의 모든 비트를 반전시킨다.
  - << : 피연산자의 비트 열을 왼쪽으로 이동시킨다.
  - 왼쪽 갈 때가 없으면 오른쪽에 0 추가가
  - '>>' : 피연산자의 비트 열을 오른쪽으로 이동시킨다.
  - 오른쪽으로 갈 때가 없으면 비트삭제
  - 연산자 순위: ~, 이동연산자, &, ^, |
  - 응용:  
    - 1 << n: 2^n 즉, 2의 n제곱의 값을 가지며, 임베디드 분야에서 계산을 빠르게 하기 위해 사용된다.
    - i &(1 << n): i의 n번째 비트가 1인지 아닌지를 확인할 수 있다.  
    - i = 5 (이진수: 0b101)  
    - idx = 1일 때, (1 << 1)은 0b10입니다.  
    - i & (1 << 1)이 0b101 & 0b010 = 0b000이면 i의 1번째 비트는 0이므로 False입니다.  
    - idx = 0일 때, (1 << 0)은 0b001입니다.  
    - i & (1 << 0)이 0b101 & 0b001 = 0b001이면 i의 0번째 비트는 1이므로 True입니다.  
    - 결괏값이 0보다 크면 n번째 비트는 1임이 확정된다.  
- bin -> 10진수 2진수로 변환
- 음수 표현 방법
- 컴퓨터는 음수를 2의 보수로 관리한다.
- 맨 앞자리 bit는 음수 or 양수를 구분하는 비트이다
- 부호 비트만 사용
- 1의 보수
- 간단하게 2진수의 값을 0->1, 1->0 했을 때 동일하면 음수라고 생각하면 된다.
- 2의 보수 -> 10001을 모두 뒤집고 +1한다.
- 01110 + 1 -> 01111
- 1111000 -> 0000111 + 1 -> 0001000
- 실수 출력 방법 : f-string 문법을 지향한다. 또는 소숫점 둘째 자리에서 반올림한다.
- ex)  {t2:.2f}
- 컴퓨터는 실수를 내부적으로 근사적으로 관리한다.
- print(0.1 + 0.1 + 0.1) == False 인데 그 이유는 실수는 근사 값으로 저장되며 이때 생기는 작은 오차가 계산 과정에서 다른 결과를 가져오기 때문이다.
- 그리고 실수는 2를 곱한 후 정수를 차례대로 출력하여 2진수로 변환해야 한다.
- **전체정리**  
  - 1. 비트연산 연산자 배움
  - 2. 실수  
    - 컴퓨터의 실수 저장 및 활용 방법
    - 근사치로 인한 오차, 반올림, 버림 등은 문제 잘 읽고 주의해야 한다.
### 완전검색
- 문제 푸는 방법.  
  - 1. 문제를 잘 읽어야 한다.
  - 2-1. 단순반복문+ 조건문으로 구현이 가능한가?
  - 2-2. 재귀호출로 모든 경우를 본다면? 
  - 그런데 이 과정까지는 시간, 공간이 부족하다.
  - 3. 규칙성을 찾아야 한다.  
    - 문제마다 숨겨진 규칙이나 패턴
    - 순간마다 최선의 선택이 정답이다.(greedy)
  - 4. 재계산을 하지 말자.  
    - 중복되는 문제의 결과를 저장해놓고 재활용하자(dp)
  - 5. 그래프(트리) 전체 노드를 탐색하자! dfs나 bfs
  - 6. 그런데 N이 너무 크면 새로운 알고리즘이나 자료 구조를 고민해야 한다.
  - 7. 알고리즘은 재귀 호출 접근법의 경우 백트래킹, 최소값/구간, 최대값/구간 등은 정렬하자
  - 8. 심화 문제들:  
    - 최단거리: dijkstra, 최소비용: MST
  - 9. 자료구조는 한 번 만들어 놓고 여러번 조회한다.
- 재귀호출에서는 return의 역할을 잘 알아야 한다.
- 중복순열 - 서로 다른 N개에서 R개를 중복을 허용하고 순서를 고려하여 나열하는 것
### 완전 탐색
- 부르트 포스- 모든 가능한 경우를 모두 시도해 정답을 찾아내는 알고리즘
**순열 조합 차이점**
- 순열은 순서가 중요, 조합은 순서가 중요하지 않다.
- 예를 들어 1,2,3에서 2개를 선택한다고 할 때 순열은 12,13, 21, 23, 31, 32 이렇게 6개가 나온다.
- 조합은 12, 13, 23 이렇게 3개가 된다.
### 그리디로 풀 수 있는 조건
- 1. 탐욕적 선택 조건  
  - 각 단계에서 최적해 선택이 이후 단계선택에 영향을 주지 않는다.
  - 즉, 각 단계 규칙이 변하면 안된다.
- 2. 최적 부분 구조  
  - 각 단계의 최적해 선택을 합하면, 전체 문제의 해결책이어야 한다.
- 3. 반례가 없는지 확인해야 한다.
### 순열 팁
- used 쓰고 if문으로 중복 되는 것을 빼야 순열이다.