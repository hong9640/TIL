절차지향 프로그래밍
- 프로그램을 함수와 로직 중심으로 작성,
-데이터를 함수에 전달하며 순차적으로 처리
ex) 변수와 함수를 별개로 다룬다.
먼저 변수가 나오고 그 밑에 함수가 나옴.
- 함수의 호출 흐름이 중요!
-순차적으로 명령어 실행
but
복잡성 증가, 유지보수 문제-코드 수종 시 영향 범위가 너무 커서 영향 범위 파악 힘듬
그래서 이를 해결하기 위해 객체지향 프로그래밍이 나옴
객체지향 프로그래밍
-데이터와 함수를 하나의 단위로 묶어서 관리
ex)
class로 묶고 그 아래에 함수를 여러개 작성
-데이터와 메서드의 결합, 프로그램을 변수와 그 데이터를 처리하는 함수를 하나의 단위로 묶어서 관리
절차지향- 어떤 순서로 처리할까?
객체 지향- 어떤 객체가 이 문제를 해결할까?
-이 객체는 어떤 속성과 기능을 가질까?
-수동적인 데이터가 능독적인 데이터로 변형
그런데 절차지향과 객체지향은 절대 대조되는 개념은 아님
-객체지향은 절차 지향을 기반에 두고 이를 보완하기 위해 객체라는 개념을 도입한 것.

객체는 속성과 동작을 가짐
클래서
-객체를 만들기 위한 설계도
-데이터와 기능을 함께 묶는 방법을 제공
클래서 안에 객체가 있는 것임
객체 특징- 속성, 메서드, 고유성
클래스- 데이터와 기능을 하나의 틀로 묶어 관리하는 방법
기본 작성 방법
class MyClass:>클래스 이름은 파스칼 케이스 방식으로 하는데 이렇게 맨 앞은 대문자로
__init__메서드는 생성자 메서드로 불림. 새로운 객체를 만들 때 필요한 초기값을 설정
인스턴스
클래스를 통해 생성된 객체
클래스는 설계도, 인스턴스는 실제로 만든 개별물

클래스와 인스턴스
-클래스-가수, 인스턴스-아이유
'', 'hello' , '파이썬'
문자열 타입(클래스)의 객체(인스턴스)
"hello".upper()-> 문자열.대문자로() 객체.행동() 인스턴스.메서드()
클래스 구조
def __init__(self, name, age):
        self.name = name  # 인스턴스 속성
        self.age = age 
-생성자 메서드, 인스턴스 생성 시 자동 호출 되는 특별한 메서드
- __init__이름의 메서드로 정의
인스턴스 변수 초기화 담당
인스턴스 변수(속성)
각 인스턴스별 고유한 속성
self.변수명 형태로 정의
인스턴스마다 독립적인 값 유지
클래스 변수-모든 인스턴스가 공유하는 속성, 클래스 내부에서 직접 정의

메서드-클래스 내부에 정의된 함수, 해당 객체가 어떻게 동작할지를 정의
1. 인스턴스
클래스 내부에서 정의되는 메서드의 기본
반드시 첫 번째 인자로 인스턴스 자신을 받음(self)
인스턴스의 속성에 접근하거나 변경 가능. self는 변경 가능하지만 변경을 절대로 권하지 않음.
self 동작원리. 'hello'.upper()은 str.upper('hello')를 객체 지향 방식의 메서드로 호출하는 표현
**self는 현재 인스턴스를 가리킨다! self.count이러면 count 라는 인스턴스 변수를 나타냄

2. 클래스
클래스가 호출하는 메서드
클래서 변수를 조작 or 글래스 레벨의 동작을 수행
호출 시 첫번째 인자로 cls가 전달됨
@classmethod
    def change_company(cls, new_company):  # 클래스 메서드
        pass
3. 스태틱
클래서, 인스턴스와 상관없이 독립적으로 동작하는 메서드
@staticmethod 데코레이터를 사용하여 정의
호출 시 자동으로 전달받는 인자가 없음
인스턴스나 클래스 속성에 직접 접근하지 않는 도우미 함수와 비슷한 역할 
인스턴스 메서드- 인스턴스의 상태를 변경하거나 특정 동작 수행
클래스 메서드- 인스턴스 상태에 의존하지 않는 기능을 정의
스태틱 메서드- 클래스, 인스턴스와 관련이 없는 기능 수행
클래스가 사용해야 할 것-클래스 메서드, 스태틱 메서드
인스턴스가 사용해야 할 것 - 인스턴스 메서드
할 수 있다 != 써도된다

클래스와 인스턴간의 이름 공간
클래스를 정의하면, 클래스와 해당하는 이름 공간 생성
인스턴스를 만들면, 인스턴스 객체가 생성되고, 독립적인 이름 공간 생성
인스턴스->클래스 순으로 탐색

독립적인 이름공간을 가지는 이점-코드의 가독성, 유지보수성, 재사용성을 높이는 데 도움을 줌.
__이거 붙은거는 매직 메서드 라고 함.
데코레이터
다른 함수의 코드를 유재한 채로 수정하거나 확장하기 위해 사용되는 함수

## 상속
상속- 한 부모 클래스의 속성과 메서드르 다른 자식 클래스가 물려받는 것
필요한 이유-코드 재사용-기존 클래스 수정 안해도 됨., 계층 구조-더 구체적인 클래스 만들 수 있음
ex) 캐릭터 안에 전사 마법사 이렇게 있음. 캐릭터라는 클래스에서 전사, 마법사에 물려줌.
자세히는 클래스 이중구조 임.
class Animal:
    def eat(self):
        print('먹는 중')

class Dog(Animal):
    def bark(self):
        print('멍멍')--> 이런식으로 클래스 안에 클래스가 들어가 있음.
메서드 오버라이딩- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의
다중 상속- 중복된 속성이나 메서드가 있는 경우, 상속 순서에 의해 결정됨.
mro 알고리즘을 사용하여 클래스 목록을 생성, mro- 파이썬이 메서드를 찾는 순서에 대한 규칙, 메서드 결정 순서
class(D(B, C): 이렇게 있으면 속성이 d에서 발견 안되면 b 에서 찾고, 거게에도 없으면 c에서 찾고 이런식으로 지행됨
super()-> 부모 클래스의 메서드를 호출하기 위해 사용하는 내장 함수
다중 상속 상황에서 특히 유용
-1. 단일 상속 구조
명시적으로 이름을 지정하지 않고 부모 클래스 참조 가능, 더 유지관리 쉽게 만들 수 있음
코드 수정이 더 적게 필요
-2. 다중 상속 구조
그런데 좀 혼란해 질 수 있는데 이렇게 되는 것을 막는 것이 개발자가 해야 할 일!
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 부모 클래스의 __init__ 호출
        self.breed = breed
이게 super 함수를 사용한 상속
class Dog(Animal):
    def speak(self):  # 부모 클래스의 speak()을 오버라이드
        print(f"{self.name} barks")
이게 오버리이딩. 메서드를 새로 덮어씀.
class Animal:
    def speak(self):
        print("Animal makes a sound")

class Mammal:
    def walk(self):
        print("Mammal can walk")

class Dog(Animal, Mammal):  # Animal과 Mammal 클래스를 상속받음
    def speak(self):
        print("Dog barks")

# 사용 예시
dog = Dog()
dog.speak()  # 출력: Dog barks
dog.walk()   # 출력: Mammal can walk
이게 다중 상속. mro는 무조건 순서대로!
super는 명시적으로 특정 부모 클래스를 가리키지 않고도 올바른 순서로 부모 초기화나 메서드 호출이 가능
mro는 무조건 순서대로이다. 호출 순서가 예측 가능하게 유지, 재사용성과 유지보수성 향상

버그- 소프트웨어에서 발생하는 오류 또는 결함. 프로그램의 예상된 동작과 실제 동작 사이의 불일치
디버깅- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정, 프로그램의 오작동 원인을 식별하여 수정하는 작업
-print하는게 가장 일반적인 방법, 파이썬 튜터를 활용하거나 눈으로 디버깅 하거나 ㅋㅋㅋㅋ
디버깅은 결국 에러를 해결하는 방법
에러-프로그램 실행 중에 발생하는 예외 상황
2개가 있음 문법에러, 예외, 
문법에러에서는 오타, 괄호 누락 등 문법적 오류
예외- 프로그램 실행 중에 감지되는 에러
내장 예외- 예외 상황을 나타내는 예외 클래스들
이런 예외는 파이썬 홈페이지 들어가면 있음. 파이썬 내장예외 찍으면 나올 거임.
예외 처리- 예외가 발생했을 때 프로그램이 적절하게 처리할 수 있도록 하는 방법
try- 예외가 발생할 수 있는 코드 작성
except- 예외가 발생했을 때 실행할 코드 작성
else-예외가 발생하지 않았을 때 실행할 코드 작성
finally- 예외 발생 여부와 상관없이 항상 실행할 코드 작성
try-except 구조- 예외가 발생하면 프로그램 흐름은 try 블록을 빠져나와 해당 예외에 대응하는 except블록으로 이동
else- finally
그렇게 많지는 않은데 추가 작업을 진행하고 finally블록은 예외 발생여부와 상관없이 항상 실행할 코드를 작성
try-except를 쓸 때는 가장 구체적이 예외부터 작성해야지 안그러면 제대로 작동 안됨
as 키워드- 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
그리고 try문은 if-else와 같이 쓸 수 있음!
EAFP - 예외처리를 중심으로 코드를 작성하는 접근 방식 try문-일단 씀! 그리고 틀리면 예외 출력
LBYL- 값 검사를 중심으로 코드를 작성하는 접근방식 if-else문- 실행하기 전에 조건을 검사


상속- 한 부모 클래스의 속성과 메서드르 다른 자식 클래스가 물려받는 것
필요한 이유-코드 재사용-기존 클래스 수정 안해도 됨., 계층 구조-더 구체적인 클래스 만들 수 있음
ex) 캐릭터 안에 전사 마법사 이렇게 있음. 캐릭터라는 클래스에서 전사, 마법사에 물려줌.
자세히는 클래스 이중구조 임.
class Animal:
    def eat(self):
        print('먹는 중')

class Dog(Animal):
    def bark(self):
        print('멍멍')--> 이런식으로 클래스 안에 클래스가 들어가 있음.
메서드 오버라이딩- 부모 클래스의 메서드를 같은 이름, 같은 파라미터 구조로 재정의
다중 상속- 중복된 속성이나 메서드가 있는 경우, 상속 순서에 의해 결정됨.
mro 알고리즘을 사용하여 클래스 목록을 생성, mro- 파이썬이 메서드를 찾는 순서에 대한 규칙, 메서드 결정 순서
class(D(B, C): 이렇게 있으면 속성이 d에서 발견 안되면 b 에서 찾고, 거게에도 없으면 c에서 찾고 이런식으로 지행됨
super()-> 부모 클래스의 메서드를 호출하기 위해 사용하는 내장 함수
다중 상속 상황에서 특히 유용
-1. 단일 상속 구조
명시적으로 이름을 지정하지 않고 부모 클래스 참조 가능, 더 유지관리 쉽게 만들 수 있음
코드 수정이 더 적게 필요
-2. 다중 상속 구조
그런데 좀 혼란해 질 수 있는데 이렇게 되는 것을 막는 것이 개발자가 해야 할 일!
class Dog(Animal):
    def __init__(self, name, breed):
        super().__init__(name)  # 부모 클래스의 __init__ 호출
        self.breed = breed
이게 super 함수를 사용한 상속
class Dog(Animal):
    def speak(self):  # 부모 클래스의 speak()을 오버라이드
        print(f"{self.name} barks")
이게 오버리이딩. 메서드를 새로 덮어씀.
class Animal:
    def speak(self):
        print("Animal makes a sound")

class Mammal:
    def walk(self):
        print("Mammal can walk")

class Dog(Animal, Mammal):  # Animal과 Mammal 클래스를 상속받음
    def speak(self):
        print("Dog barks")

# 사용 예시
dog = Dog()
dog.speak()  # 출력: Dog barks
dog.walk()   # 출력: Mammal can walk
이게 다중 상속. mro는 무조건 순서대로!
super는 명시적으로 특정 부모 클래스를 가리키지 않고도 올바른 순서로 부모 초기화나 메서드 호출이 가능
mro는 무조건 순서대로이다. 호출 순서가 예측 가능하게 유지, 재사용성과 유지보수성 향상

버그- 소프트웨어에서 발생하는 오류 또는 결함. 프로그램의 예상된 동작과 실제 동작 사이의 불일치
디버깅- 소프트웨어에서 발생하는 버그를 찾아내고 수정하는 과정, 프로그램의 오작동 원인을 식별하여 수정하는 작업
-print하는게 가장 일반적인 방법, 파이썬 튜터를 활용하거나 눈으로 디버깅 하거나 ㅋㅋㅋㅋ
디버깅은 결국 에러를 해결하는 방법
에러-프로그램 실행 중에 발생하는 예외 상황
2개가 있음 문법에러, 예외, 
문법에러에서는 오타, 괄호 누락 등 문법적 오류
예외- 프로그램 실행 중에 감지되는 에러
내장 예외- 예외 상황을 나타내는 예외 클래스들
이런 예외는 파이썬 홈페이지 들어가면 있음. 파이썬 내장예외 찍으면 나올 거임.
예외 처리- 예외가 발생했을 때 프로그램이 적절하게 처리할 수 있도록 하는 방법
try- 예외가 발생할 수 있는 코드 작성
except- 예외가 발생했을 때 실행할 코드 작성
else-예외가 발생하지 않았을 때 실행할 코드 작성
finally- 예외 발생 여부와 상관없이 항상 실행할 코드 작성
try-except 구조- 예외가 발생하면 프로그램 흐름은 try 블록을 빠져나와 해당 예외에 대응하는 except블록으로 이동
else- finally
그렇게 많지는 않은데 추가 작업을 진행하고 finally블록은 예외 발생여부와 상관없이 항상 실행할 코드를 작성
try-except를 쓸 때는 가장 구체적이 예외부터 작성해야지 안그러면 제대로 작동 안됨
as 키워드- 예외가 발생했을 때 예외에 대한 정보를 담고 있는 객체
그리고 try문은 if-else와 같이 쓸 수 있음!
EAFP - 예외처리를 중심으로 코드를 작성하는 접근 방식 try문-일단 씀! 그리고 틀리면 예외 출력
LBYL- 값 검사를 중심으로 코드를 작성하는 접근방식 if-else문- 실행하기 전에 조건을 검사